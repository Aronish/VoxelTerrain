#pragma kernel GenerateVoxelVolume

#include "Assets/Compute/Include/CSG.hlsl"
#include "Assets/Compute/Include/Noise.hlsl"

#include "Assets/Compute/Voxels/Include/Voxel.hlsl"
#include "Assets/Compute/Voxels/Include/VoxelVolume.hlsl"

int seed;
float wavelength;
uint numberOfOctaves;
float persistence;
float lacunarity;
float height;

float4 GenerateHeight(float3 position)
{
    SimplexNoise2D noise;
    float4 value_gradient = GenerateFBMNoise(seed, noise, position, numberOfOctaves, 1.0f / wavelength, persistence, lacunarity);
    value_gradient *= -height;
    value_gradient.x += position.y;
    value_gradient.z += 1.0f;

    return value_gradient;
}

[numthreads(4, 4, 4)]
void GenerateVoxelVolume(uint3 id : SV_DispatchThreadID)
{
    if (IsOutOfVoxelVolumeBounds(id))
    {
        return;
    }

    float3 worldPosition = VoxelVolumeToWorldSpace(VoxelToVoxelVolumeSpace(id));
    float4 cube = SDFCube::Create(float3(0.0f, 2.0f, 0.0f), float3(15.0f, 3.0f, 20.0f)).Evaluate(worldPosition);
    float4 sphere0 = SDFSphere::Create(float3(0.0f, 2.0f, 0.0f), 2.0f).Evaluate(worldPosition);
    float4 sphere1 = SDFSphere::Create(float3(0.0f, 2.0f, 0.0f), 5.0f).Evaluate(worldPosition);
    float4 height = GenerateHeight(worldPosition);
    float4 value_gradient = Union(sphere0, Difference(SmoothUnion(height, cube, 2.0f), sphere1));

    SetVoxel(id, Voxel::Create(value_gradient.x, value_gradient.yzw));
}
#pragma kernel GenerateInnerVertices
#pragma kernel ApplyLevelOfDetail
#pragma kernel GenerateOuterVertices
#pragma kernel GenerateTriangles

#include "Assets/Compute/Voxels/Include/Cell.hlsl"
#include "Assets/Compute/Voxels/Include/Vertex.hlsl"
#include "Assets/Compute/Voxels/Include/Voxel.hlsl"
#include "Assets/Compute/Voxels/Include/VoxelVolume.hlsl"

uint cellStride;
float cosOfSharpFeatureAngle;
uint schmitzParticleIterations;
float schmitzParticleStepSize;

RWStructuredBuffer<Vertex> generatedVertices0;
RWStructuredBuffer<Vertex> generatedVertices1;
RWStructuredBuffer<uint> generatedVerticesIndexLookupTable;
AppendStructuredBuffer<uint3> generatedTriangles;

static const uint nullVertexIndex = -1;
static const uint maxNumberOfIntersections = 6;

// Theoretically we can declare below arrays locally and pass them around functions with the "out" or "inout" modifier but that will
// result in more temporary registers being used by the compiler for some reason. See the following link for more information:
// https://gamedev.stackexchange.com/questions/190131/splitting-up-hlsl-code-into-separate-functions-causes-the-number-of-needed-tempo.
static uint numberOfIntersections;
static Vertex intersections[maxNumberOfIntersections];
static float3 forces[numberOfCellCorners];

bool IsOuterVoxel(uint3 coordinate)
{
    return any(coordinate == 0 || coordinate == numberOfVoxels - 2);
}

uint CalculateGeneratedVerticesIndexLookupTableIndex(uint3 coordinate, uint stride = 1)
{
    coordinate = IsOuterVoxel(coordinate) ? coordinate : (coordinate - 1) / stride * stride + 1;

    return dot(coordinate, uint3(1, numberOfVoxels.x - 1, (numberOfVoxels.x - 1) * (numberOfVoxels.y - 1)));
}

float3 CalculateCombinedForce(float3 center)
{
    float alpha = center.x;

    float3 force03 = alpha * forces[3] + (1.0f - alpha) * forces[0];
    float3 force47 = alpha * forces[7] + (1.0f - alpha) * forces[4];
    float3 force12 = alpha * forces[2] + (1.0f - alpha) * forces[1];
    float3 force56 = alpha * forces[6] + (1.0f - alpha) * forces[5];

    float beta = center.z;

    float3 force0347 = beta * force47 + (1.0f - beta) * force03;
    float3 force1256 = beta * force56 + (1.0f - beta) * force12;

    float gamma = center.y;

    return gamma * force1256 + (1.0f - gamma) * force0347;
}

float3 CalculateForce(float3 corner)
{
    float3 force = 0.0f;

    [unroll(maxNumberOfIntersections)]
    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        float3 position = intersections[intersectionIndex].position;
        float3 normal = intersections[intersectionIndex].normal;
        float distance = dot(normal, corner - position);
        float3 voxelCornerToPlaneVector = -distance * normal;
        force += voxelCornerToPlaneVector;
    }

    return force;
}

bool HasSharpFeature()
{
    float cosOfAngle = 1.0f;

    [unroll(maxNumberOfIntersections)]
    for (uint intersectionIndexA = 0; intersectionIndexA < numberOfIntersections; intersectionIndexA++)
    {
        Vertex intersectionA = intersections[intersectionIndexA];

        [unroll(maxNumberOfIntersections)]
        for (uint intersectionIndexB = 0; intersectionIndexB < numberOfIntersections; intersectionIndexB++)
        {
            Vertex intersectionB = intersections[intersectionIndexB];
            float newCosOfAngle = dot(intersectionA.normal, intersectionB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle : cosOfAngle;
        }
    }

    return cosOfAngle <= cosOfSharpFeatureAngle;
}

Vertex CalculateCenterVertex()
{
    Vertex vertex = Vertex::Create();

    [unroll(maxNumberOfIntersections)]
    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        vertex.position += intersections[intersectionIndex].position;
        vertex.normal += intersections[intersectionIndex].normal;
    }

    vertex.position /= numberOfIntersections;
    vertex.normal = normalize(vertex.normal);

    return vertex;
}

Vertex CalculateFeatureVertex(uint3 coordinate)
{
    Vertex vertex = CalculateCenterVertex();

    if (HasSharpFeature())
    {
        for (uint cornerIndex = 0; cornerIndex < numberOfCellCorners; cornerIndex++)
        {
            forces[cornerIndex] = CalculateForce(cellCorners[cornerIndex]);
        }

        for (uint schmitzParticleIteration = 0; schmitzParticleIteration < schmitzParticleIterations; schmitzParticleIteration++)
        {
            vertex.position = vertex.position + schmitzParticleStepSize * CalculateCombinedForce(vertex.position);
        }
    }
    vertex.position = VoxelToVoxelVolumeSpace(coordinate, ClampToCell(vertex.position));

    return vertex;
}

void CalculatePositionsAndNormals(uint3 coordinate)
{
    numberOfIntersections = 0;

    for (uint cellEdgeIndex = 0; cellEdgeIndex < numberOfCellEdges; cellEdgeIndex++)
    {
        CellEdge cellEdge = cellEdges[cellEdgeIndex];

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(coordinate + cellCornerA);
        Voxel sampleB = GetVoxel(coordinate + cellCornerB);

        if (sampleA.GetValue() >= 0.0f == sampleB.GetValue() >= 0.0f)
        {
            continue;
        }

        float interpolant = -sampleA.GetValue() / (sampleB.GetValue() - sampleA.GetValue());

        intersections[numberOfIntersections++] = Vertex::Create
        (
            lerp(cellCornerA, cellCornerB, interpolant),
            normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
        );
    }
}

[numthreads(4, 4, 4)]
void GenerateInnerVertices(uint3 id : SV_DispatchThreadID)
{
    uint3 cellID = id + 1;

    if (any(cellID > numberOfVoxels - 3))
    {
        return;
    }

    uint vertexIndex = nullVertexIndex;

    CalculatePositionsAndNormals(cellID);

    if (numberOfIntersections > 0)
    {
        vertexIndex = generatedVertices0.IncrementCounter();
        generatedVertices0[vertexIndex] = CalculateFeatureVertex(cellID);
    }
    generatedVerticesIndexLookupTable[CalculateGeneratedVerticesIndexLookupTableIndex(cellID)] = vertexIndex;
}

[numthreads(4, 4, 4)]
void ApplyLevelOfDetail(uint3 id : SV_DispatchThreadID)
{
    uint3 cellID = id * cellStride + 1;

    if (any(cellID > numberOfVoxels - 3))
    {
        return;
    }

    uint numberOfChildVertices = 0;
    uint parentVertexIndex = nullVertexIndex;
    Vertex parentVertex = Vertex::Create();

    for (uint cornerIndex = 0; cornerIndex < numberOfCellCorners; cornerIndex++)
    {
        uint3 coordinate = cellID + cellStride / 2 * cellCorners[cornerIndex];
        uint childVertexIndex = generatedVerticesIndexLookupTable[CalculateGeneratedVerticesIndexLookupTableIndex(coordinate, cellStride / 2)];

        if (childVertexIndex != nullVertexIndex)
        {
            Vertex childVertex = generatedVertices0[childVertexIndex];
            parentVertex.position += childVertex.position;
            parentVertex.normal += childVertex.normal;
            numberOfChildVertices++;
        }
    }

    if (numberOfChildVertices > 0)
    {
        parentVertexIndex = generatedVertices1.IncrementCounter();
        parentVertex.position /= numberOfChildVertices;
        parentVertex.normal = normalize(parentVertex.normal);
        generatedVertices1[parentVertexIndex] = parentVertex;
    }
    generatedVerticesIndexLookupTable[CalculateGeneratedVerticesIndexLookupTableIndex(cellID, cellStride)] = parentVertexIndex;
}

[numthreads(4, 4, 4)]
void GenerateOuterVertices(uint3 cellID : SV_DispatchThreadID)
{
    if (any(cellID > numberOfVoxels - 2) || !IsOuterVoxel(cellID))
    {
        return;
    }

    uint vertexIndex = nullVertexIndex;

    CalculatePositionsAndNormals(cellID);

    if (numberOfIntersections > 0)
    {
        vertexIndex = generatedVertices0.IncrementCounter();
        generatedVertices0[vertexIndex] = CalculateFeatureVertex(cellID);
    }
    generatedVerticesIndexLookupTable[CalculateGeneratedVerticesIndexLookupTableIndex(cellID)] = vertexIndex;
}

bool ArePairwiseDistinct(uint3 indices)
{
    return indices.x != indices.y && indices.x != indices.z && indices.y != indices.z;
}

uint3 GetVertexIndices(uint3 coordinate, uint index)
{
    const uint3 cellCornerIndices[3] =
    {
        uint3(1, 2, 3),
        uint3(4, 5, 1),
        uint3(3, 7, 4)
    };

    uint3 vertexIndices;

    [unroll]
    for (uint iterator = 0; iterator < 3; iterator++)
    {
        vertexIndices[iterator] = generatedVerticesIndexLookupTable[CalculateGeneratedVerticesIndexLookupTableIndex(coordinate + cellCorners[cellCornerIndices[index][iterator]], cellStride)];
    }

    return vertexIndices;
}

CellEdge GetCellEdge(uint index)
{
    const uint3 edgeIndices = uint3(5, 6, 10);

    return cellEdges[edgeIndices[index]];
}

[numthreads(4, 4, 4)]
void GenerateTriangles(uint3 cellID : SV_DispatchThreadID)
{
    if (any(cellID > numberOfVoxels - 3))
    {
        return;
    }

    uint vertexIndex = generatedVerticesIndexLookupTable[CalculateGeneratedVerticesIndexLookupTableIndex(cellID, cellStride)];

    for (uint index = 0; index < 3; index++)
    {
        CellEdge cellEdge = GetCellEdge(index);

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(cellID + cellCornerA);
        Voxel sampleB = GetVoxel(cellID + cellCornerB);

        if (sampleA.GetValue() >= 0.0f == sampleB.GetValue() >= 0.0f)
        {
            continue;
        }

        uint3 vertexIndices = GetVertexIndices(cellID, index);
        uint3 triangle0 = uint3(vertexIndex, vertexIndices.yx);
        uint3 triangle1 = uint3(vertexIndex, vertexIndices.zy);

        if (sampleB.GetValue() < 0.0f)
        {
            triangle0 = triangle0.xzy;
            triangle1 = triangle1.xzy;
        }

        if (ArePairwiseDistinct(triangle0))
        {
            generatedTriangles.Append(triangle0);
        }

        if (ArePairwiseDistinct(triangle1))
        {
            generatedTriangles.Append(triangle1);
        }
    }
}

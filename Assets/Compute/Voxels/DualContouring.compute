#pragma kernel GenerateVertices
#pragma kernel GenerateTriangles

#include "Assets/Compute/Voxels/Include/Cell.hlsl"
#include "Assets/Compute/Voxels/Include/Vertex.hlsl"
#include "Assets/Compute/Voxels/Include/Voxel.hlsl"
#include "Assets/Compute/Voxels/Include/VoxelVolume.hlsl"

#define NULL_VERTEX_INDEX -1

uint cellStride;
float cosOfSharpFeatureAngle;
uint schmitzParticleIterations;
float schmitzParticleStepSize;

RWStructuredBuffer<Vertex> generatedVertices;
RWStructuredBuffer<uint> generatedVertexIndicesLookupTable;
AppendStructuredBuffer<uint3> generatedTriangles;

static const uint maxNumberOfIntersections = 6;

// Theoretically we can declare below arrays locally and pass them around functions with the "out" or "inout" modifier but that will
// result in more temporary registers being used by the compiler for some reason. See the following link for more information:
// https://gamedev.stackexchange.com/questions/190131/splitting-up-hlsl-code-into-separate-functions-causes-the-number-of-needed-tempo.
static uint numberOfIntersections;
static Vertex intersections[maxNumberOfIntersections];
static float3 forces[numberOfCellCorners];

uint CalculateGeneratedVertexIndicesLookupTableIndex(uint3 coordinate)
{
    return dot(coordinate, uint3(1, numberOfVoxels.x - 1, (numberOfVoxels.x - 1) * (numberOfVoxels.y - 1)));
}

float3 CalculateCombinedForce(float3 center)
{
    float alpha = center.x;

    float3 force03 = (1.0f - alpha) * forces[0] + alpha * forces[3];
    float3 force47 = (1.0f - alpha) * forces[4] + alpha * forces[7];
    float3 force12 = (1.0f - alpha) * forces[1] + alpha * forces[2];
    float3 force56 = (1.0f - alpha) * forces[5] + alpha * forces[6];

    float beta = center.z;

    float3 force0347 = (1.0f - beta) * force03 + beta * force47;
    float3 force1256 = (1.0f - beta) * force12 + beta * force56;

    float gamma = center.y;

    float3 force03571256 = (1.0f - gamma) * force0347 + gamma * force1256;

    return force03571256;
}

float3 CalculateForce(float3 corner)
{
    float3 force = 0.0f;

    [unroll(maxNumberOfIntersections)]
    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        float3 position = intersections[intersectionIndex].position;
        float3 normal = intersections[intersectionIndex].normal;
        float distance = dot(normal, corner - position);
        float3 voxelCornerToPlaneVector = -distance * normal;
        force += voxelCornerToPlaneVector;
    }

    return force;
}

bool HasSharpFeature()
{
    float cosOfAngle = 1.0f;

    [unroll(maxNumberOfIntersections)]
    for (uint intersectionIndexA = 0; intersectionIndexA < numberOfIntersections; intersectionIndexA++)
    {
        Vertex intersectionA = intersections[intersectionIndexA];

        [unroll(maxNumberOfIntersections)]
        for (uint intersectionIndexB = 0; intersectionIndexB < numberOfIntersections; intersectionIndexB++)
        {
            Vertex intersectionB = intersections[intersectionIndexB];
            float newCosOfAngle = dot(intersectionA.normal, intersectionB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle : cosOfAngle;
        }
    }

    return cosOfAngle <= cosOfSharpFeatureAngle;
}

Vertex CalculateCenterVertex()
{
    Vertex vertex = Vertex::Create();

    [unroll(maxNumberOfIntersections)]
    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        vertex.position += intersections[intersectionIndex].position;
        vertex.normal += intersections[intersectionIndex].normal;
    }

    vertex.position /= numberOfIntersections;
    vertex.normal = normalize(vertex.normal);

    return vertex;
}

Vertex CalculateFeatureVertex(uint3 coordinate)
{
    Vertex vertex = CalculateCenterVertex();

    if (HasSharpFeature())
    {
        for (uint cornerIndex = 0; cornerIndex < numberOfCellCorners; cornerIndex++)
        {
            forces[cornerIndex] = CalculateForce(cellCorners[cornerIndex]);
        }

        for (uint schmitzParticleIteration = 0; schmitzParticleIteration < schmitzParticleIterations; schmitzParticleIteration++)
        {
            vertex.position = vertex.position + schmitzParticleStepSize * CalculateCombinedForce(vertex.position);
        }
    }

    vertex.position = VoxelToVoxelVolumeSpace(coordinate, ClampToCell(vertex.position));

    return vertex;
}

void CalculatePositionsAndNormals(uint3 coordinate)
{
    numberOfIntersections = 0;

    for (uint cellEdgeIndex = 0; cellEdgeIndex < numberOfCellEdges; cellEdgeIndex++)
    {
        CellEdge cellEdge = cellEdges[cellEdgeIndex];

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(coordinate + cellCornerA);
        Voxel sampleB = GetVoxel(coordinate + cellCornerB);

        if (sampleA.GetValue() >= 0.0f == sampleB.GetValue() >= 0.0f)
        {
            continue;
        }

        float interpolant = -sampleA.GetValue() / (sampleB.GetValue() - sampleA.GetValue());

        intersections[numberOfIntersections++] = Vertex::Create
        (
            lerp(cellCornerA, cellCornerB, interpolant),
            normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
        );
    }
}

bool IsMultipleOfStride(uint3 coordinate, uint stride)
{
    return all(coordinate % stride == 0);
}

uint CalculateStride(uint3 coordinate)
{
    bool isSurfaceCell = any(coordinate == 0 || coordinate == numberOfVoxels - 2);

    return isSurfaceCell ? 1 : cellStride;
}

bool IsOutsideBoundsForVertexGeneration(uint3 coordinate)
{
    return any(coordinate > numberOfVoxels - 2);
}

[numthreads(4, 4, 4)]
void GenerateVertices(uint3 cellID : SV_DispatchThreadID)
{
    if (IsOutsideBoundsForVertexGeneration(cellID))
    {
        return;
    }

    uint stride = CalculateStride(cellID);

    if (!IsMultipleOfStride(cellID - 1, stride))
    {
        return;
    }

    uint numberOfVertices = 0;
    uint vertexIndex = NULL_VERTEX_INDEX;
    Vertex vertex = Vertex::Create();

    for (uint x = 0; x < stride; x++)
    {
        for (uint y = 0; y < stride; y++)
        {
            for (uint z = 0; z < stride; z++)
            {
                uint3 coordinate = cellID + uint3(x, y, z);
                CalculatePositionsAndNormals(coordinate);

                if (numberOfIntersections > 0)
                {
                    if (vertexIndex == NULL_VERTEX_INDEX)
                    {
                        vertexIndex = generatedVertices.IncrementCounter();
                    }

                    Vertex featureVertex = CalculateFeatureVertex(coordinate);
                    vertex.position += featureVertex.position;
                    vertex.normal += featureVertex.normal;
                    numberOfVertices++;
                }
                generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate)] = numberOfIntersections > 0 ? vertexIndex : NULL_VERTEX_INDEX;
            }
        }
    }

    if (vertexIndex == NULL_VERTEX_INDEX)
    {
        return;
    }

    vertex.position /= numberOfVertices;
    vertex.normal = normalize(vertex.normal);
    generatedVertices[vertexIndex] = vertex;
}

bool ArePairwiseDistinct(uint3 indices)
{
    return indices.x != indices.y && indices.x != indices.z && indices.y != indices.z;
}

uint3 GetVertexIndices(uint3 coordinate, uint index)
{
    const uint3 cellCornerIndices[3] =
    {
        uint3(1, 2, 3),
        uint3(4, 5, 1),
        uint3(3, 7, 4)
    };

    uint3 vertexIndices = uint3
    (
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + cellCorners[cellCornerIndices[index][0]])],
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + cellCorners[cellCornerIndices[index][1]])],
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + cellCorners[cellCornerIndices[index][2]])]
    );

    return vertexIndices;
}

CellEdge GetCellEdge(uint index)
{
    const uint3 edgeIndices = uint3(5, 6, 10);

    return cellEdges[edgeIndices[index]];
}

bool IsOutsideBoundsForTriangleGeneration(uint3 coordinate)
{
    return any(coordinate > numberOfVoxels - 3);
}

[numthreads(4, 4, 4)]
void GenerateTriangles(uint3 cellID : SV_DispatchThreadID)
{
    if (IsOutsideBoundsForTriangleGeneration(cellID))
    {
        return;
    }

    uint vertexIndex = generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(cellID)];

    for (uint index = 0; index < 3; index++)
    {
        CellEdge cellEdge = GetCellEdge(index);

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(cellID + cellCornerA);
        Voxel sampleB = GetVoxel(cellID + cellCornerB);

        if (sampleA.GetValue() >= 0.0f == sampleB.GetValue() >= 0.0f)
        {
            continue;
        }

        uint3 vertexIndices = GetVertexIndices(cellID, index);

        uint3 triangle0 = uint3(vertexIndex, vertexIndices.yx);
        uint3 triangle1 = uint3(vertexIndex, vertexIndices.zy);

        if (sampleB.GetValue() < 0.0f)
        {
            triangle0 = triangle0.xzy;
            triangle1 = triangle1.xzy;
        }

        if (ArePairwiseDistinct(triangle0))
        {
            generatedTriangles.Append(triangle0);
        }

        if (ArePairwiseDistinct(triangle1))
        {
            generatedTriangles.Append(triangle1);
        }
    }
}

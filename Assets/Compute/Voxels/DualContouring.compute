#pragma kernel GenerateVertices
#pragma kernel GenerateTriangles

#include "Assets/Compute/Voxels/Include/Cell.hlsl"
#include "Assets/Compute/Voxels/Include/Vertex.hlsl"
#include "Assets/Compute/Voxels/Include/Voxel.hlsl"
#include "Assets/Compute/Voxels/Include/VoxelVolume.hlsl"

uint cellStride;
float cosOfSharpFeatureAngle;
uint schmitzParticleIterations;
float schmitzParticleStepSize;

RWStructuredBuffer<Vertex> generatedVertices;
RWStructuredBuffer<uint> generatedVertexIndicesLookupTable;
AppendStructuredBuffer<uint3> generatedTriangles;

static const uint maxNumberOfIntersections = 6;

static uint numberOfIntersections;
static Vertex intersections[maxNumberOfIntersections];
static float3 forces[numberOfCellCorners];

bool IsOutsideBoundsForVertexGeneration(uint3 coordinate)
{
    return any(step(numberOfVoxels - 1, coordinate));
}

void CalculatePositionsAndNormals(uint3 coordinate, uint stride)
{
    numberOfIntersections = 0;

    for (uint cellEdgeIndex = 0; cellEdgeIndex < numberOfCellEdges; cellEdgeIndex++)
    {
        CellEdge cellEdge = cellEdges[cellEdgeIndex];

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(coordinate + stride * cellCornerA);
        Voxel sampleB = GetVoxel(coordinate + stride * cellCornerB);

        if (sampleA.GetValue() >= 0.0f != sampleB.GetValue() >= 0.0f)
        {
            float interpolant = -sampleA.GetValue() / (sampleB.GetValue() - sampleA.GetValue());

            intersections[numberOfIntersections++] = Vertex::Create
            (
                lerp(cellCornerA, cellCornerB, interpolant),
                normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
            );
        }
    }
}

float3 CalculateCombinedForce(float3 center)
{
    float alpha = center.x;

    float3 force03 = (1.0f - alpha) * forces[0] + alpha * forces[3];
    float3 force47 = (1.0f - alpha) * forces[4] + alpha * forces[7];
    float3 force12 = (1.0f - alpha) * forces[1] + alpha * forces[2];
    float3 force56 = (1.0f - alpha) * forces[5] + alpha * forces[6];

    float beta = center.z;

    float3 force0347 = (1.0f - beta) * force03 + beta * force47;
    float3 force1256 = (1.0f - beta) * force12 + beta * force56;

    float gamma = center.y;

    return(1.0f - gamma) * force0347 + gamma * force1256;
}

float3 CalculateForce(float3 corner)
{
    float3 force = 0.0f;

    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        float3 position = intersections[intersectionIndex].position;
        float3 normal = intersections[intersectionIndex].normal;
        float distance = dot(normal, corner - position);
        float3 voxelCornerToPlaneVector = -distance * normal;
        force += voxelCornerToPlaneVector;
    }

    return force;
}

bool HasSharpFeature()
{
    float cosOfAngle = 1.0f;

    for (uint intersectionIndexA = 0; intersectionIndexA < numberOfIntersections; intersectionIndexA++)
    {
        Vertex intersectionA = intersections[intersectionIndexA];

        for (uint intersectionIndexB = 0; intersectionIndexB < numberOfIntersections; intersectionIndexB++)
        {
            Vertex intersectionB = intersections[intersectionIndexB];
            float newCosOfAngle = dot(intersectionA.normal, intersectionB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle : cosOfAngle;
        }
    }

    return cosOfAngle <= cosOfSharpFeatureAngle;
}

Vertex CalculateCenterVertex()
{
    Vertex vertex = Vertex::Create();

    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        vertex.position += intersections[intersectionIndex].position;
        vertex.normal += intersections[intersectionIndex].normal;
    }

    vertex.position /= numberOfIntersections;
    vertex.normal = normalize(vertex.normal);

    return vertex;
}

Vertex CalculateVertex(uint3 coordinate, uint stride)
{
    Vertex vertex = CalculateCenterVertex();

    if (HasSharpFeature())
    {
        for (uint cornerIndex = 0; cornerIndex < numberOfCellCorners; cornerIndex++)
        {
            forces[cornerIndex] = CalculateForce(cellCorners[cornerIndex]);
        }

        for (uint schmitzParticleIteration = 0; schmitzParticleIteration < schmitzParticleIterations; schmitzParticleIteration++)
        {
            vertex.position = vertex.position + schmitzParticleStepSize * CalculateCombinedForce(vertex.position);
        }
    }

    vertex.position = ClampToCell(vertex.position, 1e-3f);
    vertex.position = stride * voxelSpacing * vertex.position + VoxelToVoxelVolumeSpace(coordinate);

    return vertex;
}

uint CalculateGeneratedVertexIndicesLookupTableIndex(uint3 coordinate)
{
    return dot(coordinate, uint3(1, numberOfVoxels.x - 1, (numberOfVoxels.x - 1) * (numberOfVoxels.y - 1)));
}

[numthreads(4, 4, 4)]
void GenerateVertices(uint3 id : SV_DispatchThreadID)
{
    uint stride = cellStride;

    if (any(id % stride != 0))
    {
        return;
    }

    if (IsOutsideBoundsForVertexGeneration(id))
    {
        return;
    }

    CalculatePositionsAndNormals(id, stride);
    uint vertexIndex = -1;

    if (numberOfIntersections > 0)
    {
        vertexIndex = generatedVertices.IncrementCounter();
        generatedVertices[vertexIndex] = CalculateVertex(id, stride);
    }

    generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(id)] = vertexIndex;
}

uint3 GetVertexIndices(uint3 coordinate, uint index, uint stride)
{
    const uint3 cellCornerIndices[3] =
    {
        uint3(3, 2, 1),
        uint3(4, 5, 1),
        uint3(3, 7, 4)
    };

    uint3 vertexIndices = uint3
    (
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + stride * cellCorners[cellCornerIndices[index][0]])],
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + stride * cellCorners[cellCornerIndices[index][1]])],
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + stride * cellCorners[cellCornerIndices[index][2]])]
    );

    return vertexIndices;
}

CellEdge GetCellEdge(uint index)
{
    const uint3 edgeIndices = uint3(5, 6, 10);

    return cellEdges[edgeIndices[index]];
}

bool IsOutsideBoundsForTriangleGeneration(uint3 coordinate, uint stride)
{
    return any(step(numberOfVoxels - 1 - stride, coordinate));
}

[numthreads(4, 4, 4)]
void GenerateTriangles(uint3 id : SV_DispatchThreadID)
{
    uint stride = cellStride;
    
    if (any(id % stride != 0))
    {
        return;
    }

    if (IsOutsideBoundsForTriangleGeneration(id, stride))
    {
        return;
    }

    uint vertexIndex = generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(id)];

    if (vertexIndex == -1)
    {
        return;
    }

    for (uint index = 0; index < 3; index++)
    {
        CellEdge cellEdge = GetCellEdge(index);

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(id + stride * cellCornerA);
        Voxel sampleB = GetVoxel(id + stride * cellCornerB);

        if (sampleA.GetValue() >= 0.0f != sampleB.GetValue() >= 0.0f)
        {
            uint3 vertexIndices = GetVertexIndices(id, index, stride);

            uint3 triangle0 = uint3(vertexIndex, vertexIndices.yx);
            uint3 triangle1 = uint3(vertexIndex, vertexIndices.zy);

            if (sampleA.GetValue() < 0.0f == (index == 0))
            {
                triangle0 = triangle0.xzy;
                triangle1 = triangle1.xzy;
            }

            generatedTriangles.Append(triangle0);
            generatedTriangles.Append(triangle1);
        }
    }
}

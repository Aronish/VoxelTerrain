#pragma kernel GenerateVertices
#pragma kernel GenerateTriangles

#include "Assets/Compute/Voxels/Include/Cell.hlsl"
#include "Assets/Compute/Voxels/Include/Vertex.hlsl"
#include "Assets/Compute/Voxels/Include/Voxel.hlsl"
#include "Assets/Compute/Voxels/Include/VoxelVolume.hlsl"

uint cellStride;
float cosOfSharpFeatureAngle;
uint schmitzParticleIterations;
float schmitzParticleStepSize;

RWStructuredBuffer<Vertex> generatedVertices;
RWStructuredBuffer<uint> generatedVertexIndicesLookupTable;
AppendStructuredBuffer<uint3> generatedTriangles;

static const uint maxNumberOfIntersections = 6;

static uint numberOfIntersections;
static Vertex intersections[maxNumberOfIntersections];
static float3 forces[numberOfCellCorners];

uint CalculateGeneratedVertexIndicesLookupTableIndex(uint3 coordinate)
{
    return dot(coordinate, uint3(1, numberOfVoxels.x - 1, (numberOfVoxels.x - 1) * (numberOfVoxels.y - 1)));
}

float3 CalculateCombinedForce(float3 center)
{
    float alpha = center.x;

    float3 force03 = (1.0f - alpha) * forces[0] + alpha * forces[3];
    float3 force47 = (1.0f - alpha) * forces[4] + alpha * forces[7];
    float3 force12 = (1.0f - alpha) * forces[1] + alpha * forces[2];
    float3 force56 = (1.0f - alpha) * forces[5] + alpha * forces[6];

    float beta = center.z;

    float3 force0347 = (1.0f - beta) * force03 + beta * force47;
    float3 force1256 = (1.0f - beta) * force12 + beta * force56;

    float gamma = center.y;

    float3 force03471256 = (1.0f - gamma) * force0347 + gamma * force1256;

    return force03471256;
}

float3 CalculateForce(float3 corner)
{
    float3 force = 0.0f;

    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        float3 position = intersections[intersectionIndex].position;
        float3 normal = intersections[intersectionIndex].normal;
        float distance = dot(normal, corner - position);
        float3 voxelCornerToPlaneVector = -distance * normal;
        force += voxelCornerToPlaneVector;
    }

    return force;
}

bool HasSharpFeature()
{
    float cosOfAngle = 1.0f;

    for (uint intersectionIndexA = 0; intersectionIndexA < numberOfIntersections; intersectionIndexA++)
    {
        Vertex intersectionA = intersections[intersectionIndexA];

        for (uint intersectionIndexB = 0; intersectionIndexB < numberOfIntersections; intersectionIndexB++)
        {
            Vertex intersectionB = intersections[intersectionIndexB];
            float newCosOfAngle = dot(intersectionA.normal, intersectionB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle : cosOfAngle;
        }
    }

    return cosOfAngle <= cosOfSharpFeatureAngle;
}

Vertex CalculateCenterVertex()
{
    Vertex vertex = Vertex::Create();

    for (uint intersectionIndex = 0; intersectionIndex < numberOfIntersections; intersectionIndex++)
    {
        vertex.position += intersections[intersectionIndex].position;
        vertex.normal += intersections[intersectionIndex].normal;
    }

    vertex.position /= numberOfIntersections;
    vertex.normal = normalize(vertex.normal);

    return vertex;
}

Vertex CalculateVertex(uint3 coordinate, uint stride)
{
    Vertex vertex = CalculateCenterVertex();

    if (HasSharpFeature())
    {
        for (uint cornerIndex = 0; cornerIndex < numberOfCellCorners; cornerIndex++)
        {
            forces[cornerIndex] = CalculateForce(cellCorners[cornerIndex]);
        }

        for (uint schmitzParticleIteration = 0; schmitzParticleIteration < schmitzParticleIterations; schmitzParticleIteration++)
        {
            vertex.position = vertex.position + schmitzParticleStepSize * CalculateCombinedForce(vertex.position);
        }
    }

    vertex.position = ClampToCell(vertex.position);
    vertex.position = VoxelToVoxelVolumeSpace(coordinate, stride * vertex.position);

    return vertex;
}

void CalculatePositionsAndNormals(uint3 coordinate, uint stride)
{
    numberOfIntersections = 0;

    for (uint cellEdgeIndex = 0; cellEdgeIndex < numberOfCellEdges; cellEdgeIndex++)
    {
        CellEdge cellEdge = cellEdges[cellEdgeIndex];

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(coordinate + stride * cellCornerA);
        Voxel sampleB = GetVoxel(coordinate + stride * cellCornerB);

        if (sampleA.GetValue() >= 0.0f == sampleB.GetValue() >= 0.0f)
        {
            continue;
        }

        float interpolant = -sampleA.GetValue() / (sampleB.GetValue() - sampleA.GetValue());

        intersections[numberOfIntersections++] = Vertex::Create
        (
            lerp(cellCornerA, cellCornerB, interpolant),
            normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
        );
    }
}

bool IsMultipleOfStride(uint3 coordinate, uint stride)
{
    return all(coordinate % stride == 0);
}

bool IsOutsideBoundsForVertexGeneration(uint3 coordinate)
{
    return any(coordinate > numberOfVoxels - 2);
}

[numthreads(4, 4, 4)]
void GenerateVertices(uint3 cellID : SV_DispatchThreadID)
{
    if (IsOutsideBoundsForVertexGeneration(cellID))
    {
        return;
    }
    
    uint vertexIndex = -1;

    if (!IsMultipleOfStride(cellID, cellStride))
    {
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(cellID)] = vertexIndex;

        return;
    }

    CalculatePositionsAndNormals(cellID, cellStride);

    if (numberOfIntersections > 0)
    {
        vertexIndex = generatedVertices.IncrementCounter();
        generatedVertices[vertexIndex] = CalculateVertex(cellID, cellStride);
    }
    generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(cellID)] = vertexIndex;
}

uint3 GetVertexIndices(uint3 coordinate, uint index, uint stride)
{
    const uint3 cellCornerIndices[3] =
    {
        uint3(1, 2, 3),
        uint3(4, 5, 1),
        uint3(3, 7, 4)
    };

    uint3 vertexIndices = uint3
    (
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + stride * cellCorners[cellCornerIndices[index][0]])],
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + stride * cellCorners[cellCornerIndices[index][1]])],
        generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(coordinate + stride * cellCorners[cellCornerIndices[index][2]])]
    );

    return vertexIndices;
}

CellEdge GetCellEdge(uint index)
{
    const uint3 edgeIndices = uint3(5, 6, 10);

    return cellEdges[edgeIndices[index]];
}

bool IsOutsideBoundsForTriangleGeneration(uint3 coordinate, uint stride)
{
    return any(coordinate > numberOfVoxels - 2 - stride);
}

[numthreads(4, 4, 4)]
void GenerateTriangles(uint3 cellID : SV_DispatchThreadID)
{
    if (IsOutsideBoundsForTriangleGeneration(cellID, cellStride))
    {
        return;
    }

    if (!IsMultipleOfStride(cellID, cellStride))
    {
        return;
    }

    uint vertexIndex = generatedVertexIndicesLookupTable[CalculateGeneratedVertexIndicesLookupTableIndex(cellID)];

    if (vertexIndex == -1)
    {
        return;
    }

    for (uint index = 0; index < 3; index++)
    {
        CellEdge cellEdge = GetCellEdge(index);

        uint3 cellCornerA = cellCorners[cellEdge.GetCornerStartIndex()];
        uint3 cellCornerB = cellCorners[cellEdge.GetCornerEndIndex()];

        Voxel sampleA = GetVoxel(cellID + cellStride * cellCornerA);
        Voxel sampleB = GetVoxel(cellID + cellStride * cellCornerB);

        if (sampleA.GetValue() >= 0.0f == sampleB.GetValue() >= 0.0f)
        {
            continue;
        }

        uint3 vertexIndices = GetVertexIndices(cellID, index, cellStride);

        uint3 triangle0 = uint3(vertexIndex, vertexIndices.yx);
        uint3 triangle1 = uint3(vertexIndex, vertexIndices.zy);

        if (sampleB.GetValue() < 0.0f)
        {
            triangle0 = triangle0.xzy;
            triangle1 = triangle1.xzy;
        }

        generatedTriangles.Append(triangle0);
        generatedTriangles.Append(triangle1);
    }
}

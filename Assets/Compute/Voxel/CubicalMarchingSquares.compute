#pragma kernel GenerateFlatFeatureVertices
#pragma kernel GenerateSharpFeatureVertices

// If the marching cubes algorithm generates vertices for each cell independently, many duplicate vertices will be generated.
// To avoid this for this cubical marching squares implementation I use the same approach as described in
// https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu
// to first generate the marching cubes edge (here called flat) vertices for the entire volume in kernel 0 and then
// generating the remaining (here called sharp) vertices in kernel 1. A lookup table is used to retrieve
// the flat vertices generated in kernel 0 from kernel 1 (see link, specifically "Generating a Block: Method 3").

#include "Assets/Compute/Voxel/Include/Cell.hlsl"
#include "Assets/Compute/Voxel/Include/CellVolume.hlsl"
#include "Assets/Compute/Voxel/Include/Component.hlsl"
#include "Assets/Compute/Voxel/Include/MarchingSquares.hlsl"
#include "Assets/Compute/Voxel/Include/Segment.hlsl"
#include "Assets/Compute/Voxel/Include/Vertex.hlsl"
#include "Assets/Compute/Voxel/Include/Voxel.hlsl"
#include "Assets/Compute/Voxel/Include/VoxelVolume.hlsl"

#include "Assets/Compute/Include/Flags.hlsl"

static const uint3 cellEdgeIndicesForFlatVertexGeneration = uint3(0, 3, 8);

// Convenience struct, instances of which act as entries into the lookup table described above.
struct CellFlatFeatureVertexIndices
{
    uint3 vertexIndices;

    uint GetFlatVertexIndex(uint index)
    {
        return vertexIndices[index];
    }

    void SetFlatVertexIndex(uint index, uint vertexIndex)
    {
        vertexIndices[index] = vertexIndex;
    }

    static CellFlatFeatureVertexIndices Create(uint edge0VertexIndex = -1, uint edge3VertexIndex = -1, uint edge8VertexIndex = -1)
    {
        CellFlatFeatureVertexIndices cellFlatFeatureVertexIndices;
        cellFlatFeatureVertexIndices.vertexIndices = uint3(edge0VertexIndex, edge3VertexIndex, edge8VertexIndex);

        return cellFlatFeatureVertexIndices;
    }
};

float cosOfSharpFeatureAngle;
uint maxIterations;
float stepSize;

RWStructuredBuffer<Vertex> generatedVertices;
RWStructuredBuffer<CellFlatFeatureVertexIndices> flatFeatureVertexIndicesLookupTable;
AppendStructuredBuffer<uint3> generatedTriangles;

static Voxel samples[cellCornersCount];
static Segment segments[maxSegmentsCount];
static Component components[maxComponentsCount];
static float3 forces[cellCornersCount];

void SampleVoxelVolume(uint3 cellID)
{
    for (uint cornerIndex = 0; cornerIndex < cellCornersCount; cornerIndex++)
    {
        uint3 voxelID = ClampToVoxelVolumeBounds(cellID + cellCorners[cornerIndex]);
        samples[cornerIndex] = voxelVolume[CalculateVoxelVolumeIndex(voxelID)];
    }
}

uint GenerateFlatFeatureVertex(uint3 cellID, CellEdge edge)
{
    uint3 cellCornerA = cellCorners[edge.GetCornerStartIndex()];
    uint3 cellCornerB = cellCorners[edge.GetCornerEndIndex()];

    Voxel voxelA = samples[edge.GetCornerStartIndex()];
    Voxel voxelB = samples[edge.GetCornerEndIndex()];

    if (voxelA.GetValue() < 0.0f == voxelB.GetValue() < 0.0f)
    {
        return -1;
    }

    float interpolant = -voxelA.GetValue() / (voxelB.GetValue() - voxelA.GetValue());

    uint vertexIndex = generatedVertices.IncrementCounter();

    generatedVertices[vertexIndex] = Vertex::Create
    (
        CellToCellVolumeSpace(cellID, lerp(cellCornerA, cellCornerB, interpolant)),
        normalize(lerp(voxelA.GetGradient(), voxelB.GetGradient(), interpolant))
    );

    return vertexIndex;
}

[numthreads(4, 4, 4)]
void GenerateFlatFeatureVertices(uint3 cellID : SV_DispatchThreadID)
{
    if (IsOutOfVoxelVolumeBounds(cellID))
    {
        return;
    }

    SampleVoxelVolume(cellID);

    CellFlatFeatureVertexIndices cellFlatFeatureVertexIndices = CellFlatFeatureVertexIndices::Create();

    [unroll]
    for (uint index = 0; index < 3; index++)
    {
        uint edgeIndex = cellEdgeIndicesForFlatVertexGeneration[index];
        uint vertexIndex = GenerateFlatFeatureVertex(cellID, cellEdges[edgeIndex]);
        cellFlatFeatureVertexIndices.SetFlatVertexIndex(index, vertexIndex);
    }

    flatFeatureVertexIndicesLookupTable[CalculateVoxelVolumeIndex(cellID)] = cellFlatFeatureVertexIndices;
}

uint GetFlatFeatureVertexIndex(uint3 cellID, uint edgeIndex)
{
    // For certain edges of the current cell we need to look into adjacent
    // cells to find the corresponding flat vertex index. This relationship
    // between edges and corresponding flat vertex indices is mapped in this
    // array.
    const uint4 edgeIndexToFlatVertexIndexMapping[12] =
    {
        uint4(0, 0, 0, 0),
        uint4(1, 0, 0, 1),
        uint4(0, 1, 0, 0),
        uint4(0, 0, 0, 1),
        uint4(0, 0, 1, 0),
        uint4(1, 0, 1, 1),
        uint4(0, 1, 1, 0),
        uint4(0, 0, 1, 1),
        uint4(0, 0, 0, 2),
        uint4(1, 0, 0, 2),
        uint4(1, 1, 0, 2),
        uint4(0, 1, 0, 2)
    };

    uint4 mapping = edgeIndexToFlatVertexIndexMapping[edgeIndex];

    return flatFeatureVertexIndicesLookupTable[CalculateVoxelVolumeIndex(cellID + mapping.xyz)].GetFlatVertexIndex(mapping.w);
}

uint2 GenerateFaceSharpFeatureVertices(uint3 cellID, CellFace cellFace, Vertex vertexA, Vertex vertexB)
{
    if (dot(vertexA.normal, vertexB.normal) > cosOfSharpFeatureAngle)
    {
        return -1;
    }

    float3 faceTangentA = cellFace.GetFaceTangent(vertexA.normal);
    float3 faceTangentB = cellFace.GetFaceTangent(vertexB.normal);
    
    float3 lineVec3 = vertexB.position - vertexA.position;
    float3 crossVec1and2 = cross(faceTangentA, faceTangentB);
    float3 crossVec3and2 = cross(lineVec3, faceTangentB);
    float s = dot(crossVec3and2, crossVec1and2) / dot(crossVec1and2, crossVec1and2);
    float3 sharpFeaturePosition = vertexA.position + (faceTangentA * s);

    // A single segment sharp feature is shared between exactly two segments, one segment belonging to the current cell
    // and the other belonging to the adjacent cell sharing the same cell face. Therefore the position of the sharp feature
    // will be independently calculated twice. Due to floating point errors both calculated sharp feature positions can be
    // slightly different. This can result in one of both being "outside" the cell while the other one isn't.
    // To compensate for this potential discrepancy a small value (epsilon) is added to the extents of the cell for the check.
    if (IsOutsideCell(CellVolumeToCellSpace(cellID, sharpFeaturePosition), 1e-3f) || any(isnan(sharpFeaturePosition)))
    {
        return -1;
    }

    uint2 vertexIndices = uint2(generatedVertices.IncrementCounter(), generatedVertices.IncrementCounter());

    generatedVertices[vertexIndices.x] = Vertex::Create(sharpFeaturePosition, vertexA.normal);
    generatedVertices[vertexIndices.y] = Vertex::Create(sharpFeaturePosition, vertexB.normal);

    return vertexIndices;
}

uint GenerateFaceSegments(uint3 cellID, CellFace cellFace, uint segmentsCount)
{
    uint segmentsIndex = 0;
    
    for (uint cornerIndex = 0; cornerIndex < 4; cornerIndex++)
    {
        Voxel voxel = samples[cellFace.cornerIndices[cornerIndex]];
        segmentsIndex |= (voxel.GetValue() < 0.0f) << cornerIndex;
    }

    uint4 faceSegments = marchingSquaresSegments[segmentsIndex];

    for (uint faceSegmentsIndex = 0; faceSegmentsIndex < 4; faceSegmentsIndex += 2)
    {
        if (faceSegments[faceSegmentsIndex] == -1)
        {
            break;
        }

        uint edgeIndexA = cellFace.edgeIndices[faceSegments[faceSegmentsIndex + 0]];
        uint edgeIndexB = cellFace.edgeIndices[faceSegments[faceSegmentsIndex + 1]];

        uint vertexIndexA = GetFlatFeatureVertexIndex(cellID, edgeIndexA);
        uint vertexIndexB = GetFlatFeatureVertexIndex(cellID, edgeIndexB);

        Vertex vertexA = generatedVertices[vertexIndexA];
        Vertex vertexB = generatedVertices[vertexIndexB];
        
        Segment segment = Segment::Create
        (
            edgeIndexA,
            vertexIndexA,
            edgeIndexB,
            vertexIndexB,
            GenerateFaceSharpFeatureVertices(cellID, cellFace, vertexA, vertexB)
        );

        segments[segmentsCount++] = segment;
    }
    return segmentsCount;
}

uint TraceComponents(uint segmentsCount)
{
    for (uint componentsIndex = 0; componentsIndex < maxComponentsCount; componentsIndex++)
    {
        components[componentsIndex] = Component::Create();
    }

    Flags segmentsAssigned = Flags::Create();
    uint componentsCount = 0;
    uint segmentsIndex = -1;
    uint remainingSegmentsToAssign = segmentsCount;

    while(remainingSegmentsToAssign > 0)
    {
        segmentsIndex = (segmentsIndex + 1) % segmentsCount;

        if (segmentsAssigned.HasFlag(segmentsIndex))
        {
            continue;
        }

        uint componentLength = 0;
        uint start = segments[segmentsIndex].GetEdgeIndexA();
        uint end = segments[segmentsIndex].GetEdgeIndexB();
        segmentsAssigned.SetFlag(segmentsIndex);
        components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
        componentLength++;
        remainingSegmentsToAssign--;

        while(start != end)
        {
            segmentsIndex = (segmentsIndex + 1) % segmentsCount;

            if (segmentsAssigned.HasFlag(segmentsIndex))
            {
                continue;
            }

            Segment segment = segments[segmentsIndex];

            if (end == segment.GetEdgeIndexA() || end == segment.GetEdgeIndexB())
            {
                bool flipped = end == segment.GetEdgeIndexB();

                if (flipped)
                {
                    segments[segmentsIndex].SwapEdges();
                }

                end = segments[segmentsIndex].GetEdgeIndexB();
                segmentsAssigned.SetFlag(segmentsIndex);
                components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
                componentLength++;
                remainingSegmentsToAssign--;
            }
        }
        components[componentsCount].SetLength(componentLength);
        componentsCount++;
    }
    return componentsCount;
}

Vertex CalculateCenterVertex(Component component)
{
    Vertex centerVertex = Vertex::Create();

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];
        Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
        centerVertex.position += vertex.position;
        centerVertex.normal += vertex.normal;
    }

    centerVertex.position /= index;
    centerVertex.normal = normalize(centerVertex.normal);

    return centerVertex;
}

bool HasSharpFeature(Component component)
{
    float cosOfAngle = 1.0f;

    for (uint indexA = 0; indexA < component.GetLength(); indexA++)
    {
        Segment segmentA = segments[component.GetPackedSegmentsIndex(indexA)];
        Vertex vertexA = generatedVertices[segmentA.GetEdgeVertexIndexA()];

        for (uint indexB = 0; indexB < component.GetLength(); indexB++)
        {
            Segment segmentB = segments[component.GetPackedSegmentsIndex(indexB)];
            Vertex vertexB = generatedVertices[segmentB.GetEdgeVertexIndexA()];
            float newCosOfAngle = dot(vertexA.normal, vertexB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle : cosOfAngle;
        }
    }
    return cosOfAngle <= cosOfSharpFeatureAngle;
}

void CalculateForces(Component component)
{
    for (uint cornerIndex = 0; cornerIndex < cellCornersCount; cornerIndex++)
    {
        forces[cornerIndex] = 0.0f;

        for (uint index = 0; index < component.GetLength(); index++)
        {
            Segment segment = segments[component.GetPackedSegmentsIndex(index)];
            Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
            float distance = dot(vertex.normal, cellCorners[cornerIndex] - vertex.position);
            forces[cornerIndex] -= distance * vertex.normal;
        }
    }
}

float3 CalculateCombinedForce(float3 alpha_beta_gamma)
{
    float3 force03 = (1.0f - alpha_beta_gamma.x) * forces[0] + alpha_beta_gamma.x * forces[3];
    float3 force12 = (1.0f - alpha_beta_gamma.x) * forces[1] + alpha_beta_gamma.x * forces[2];
    float3 force47 = (1.0f - alpha_beta_gamma.x) * forces[4] + alpha_beta_gamma.x * forces[7];
    float3 force56 = (1.0f - alpha_beta_gamma.x) * forces[5] + alpha_beta_gamma.x * forces[6];

    float3 force0347 = (1.0f - alpha_beta_gamma.y) * force03 + alpha_beta_gamma.y * force47;
    float3 force1256 = (1.0f - alpha_beta_gamma.y) * force12 + alpha_beta_gamma.y * force56;

    return(1.0f - alpha_beta_gamma.z) * force0347 + alpha_beta_gamma.z * force1256;
}

Vertex CalculateComponentFeatureVertex(uint3 cellID, Component component, out bool isComponentSharpFeature)
{
    Vertex featureVertex = CalculateCenterVertex(component);

    isComponentSharpFeature = HasSharpFeature(component);

    // If the component has a sharp feature, solve for it by using the "Schmitz Particle Method" (http://www.inf.ufrgs.br/~comba/papers/thesis/diss-leonardo.pdf).
    // This method is much faster to compute than solving the QEF and iteratively approximates the analytical QEF result.
    if (isComponentSharpFeature)
    {
        CalculateForces(component);

        for (uint iterations = 0; iterations < maxIterations; iterations++)
        {
            featureVertex.position += stepSize * CalculateCombinedForce(featureVertex.position.yzx);
        }
    }
    featureVertex.position = CellToCellVolumeSpace(cellID, ClampToCell(CellVolumeToCellSpace(cellID, featureVertex.position), 1e-3f));
    
    return featureVertex;
}

void GenerateTriangle(uint componentFeatureVertex, bool isComponentSharpFeature, uint segmentVertexIndex0, uint segmentVertexIndex1)
{
    if (isComponentSharpFeature)
    {
        Vertex componentSharpFeatureVertex = generatedVertices[componentFeatureVertex];
        Vertex segmentVertex0 = generatedVertices[segmentVertexIndex0];
        Vertex segmentVertex1 = generatedVertices[segmentVertexIndex1];

        float3 normal = normalize(cross(segmentVertex0.position - componentSharpFeatureVertex.position, segmentVertex1.position - componentSharpFeatureVertex.position));

        generatedVertices[componentFeatureVertex].normal = normal;
    }

    generatedTriangles.Append(uint3(componentFeatureVertex, segmentVertexIndex0, segmentVertexIndex1));
}

void GenerateTriangles(Component component, Vertex componentFeatureVertex, bool isComponentSharpFeature)
{
    uint componentFeatureVertexIndex = -1;

    if (!isComponentSharpFeature)
    {
        componentFeatureVertexIndex = generatedVertices.IncrementCounter();
        generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
    }

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];

        if (segment.HasSharpFeature())
        {
            if (isComponentSharpFeature)
            {
                componentFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            }
            GenerateTriangle(componentFeatureVertexIndex, isComponentSharpFeature, segment.GetSharpFeatureVertexIndexA(), segment.GetEdgeVertexIndexA());

            if (isComponentSharpFeature)
            {
                componentFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            }
            GenerateTriangle(componentFeatureVertexIndex, isComponentSharpFeature, segment.GetEdgeVertexIndexB(), segment.GetSharpFeatureVertexIndexB());
        }
        else
        {
            if (isComponentSharpFeature)
            {
                componentFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            }
            GenerateTriangle(componentFeatureVertexIndex, isComponentSharpFeature, segment.GetEdgeVertexIndexB(), segment.GetEdgeVertexIndexA());
        }
    }
}

[numthreads(4, 4, 4)]
void GenerateSharpFeatureVertices(uint3 cellID : SV_DispatchThreadID)
{
    if (IsOutOfCellBounds(cellID))
    {
        return;
    }

    SampleVoxelVolume(cellID);

    uint segmentsCount = 0;

    for (uint faceIndex = 0; faceIndex < cellFacesCount; faceIndex++)
    {
        segmentsCount = GenerateFaceSegments(cellID, cellFaces[faceIndex], segmentsCount);
    }

    if (segmentsCount == 0)
    {
        return;
    }

    uint componentsCount = TraceComponents(segmentsCount);
    
    for (uint componentsIndex = 0; componentsIndex < componentsCount; componentsIndex++)
    {
        bool isComponentSharpFeature;
        Vertex componentFeatureVertex = CalculateComponentFeatureVertex(cellID, components[componentsIndex], isComponentSharpFeature);
        GenerateTriangles(components[componentsIndex], componentFeatureVertex, isComponentSharpFeature);
    }
}
#pragma kernel GenerateVoxelVolume

#include "Assets/Compute/Voxel/Include/CellVolume.hlsl"
#include "Assets/Compute/Voxel/Include/Voxel.hlsl"
#include "Assets/Compute/Voxel/Include/VoxelVolume.hlsl"

#include "Assets/Compute/Include/Noise.hlsl"
#include "Assets/Compute/Include/SDF.hlsl"

float wavelength;
uint numberOfOctaves;
float persistence;
float lacunarity;
float height;

Buffer<float3> octaveOffsets;

float4 GenerateHeight(float3 position)
{
    SimplexNoise2D noise;
    float4 value_gradient = GenerateFBMNoise(noise, position, numberOfOctaves, octaveOffsets, 1.0f / wavelength, persistence, lacunarity);

    value_gradient *= -height;
    value_gradient.x += position.y;
    value_gradient.z += 1.0f;

    return value_gradient;
}

[numthreads(4, 4, 4)]
void GenerateVoxelVolume(uint3 voxelID : SV_DispatchThreadID)
{
    if (IsOutOfVoxelVolumeBounds(voxelID))
    {
        return;
    }

    float3 worldPosition = CellVolumeToWorldSpace(CellToCellVolumeSpace(voxelID));

    float4 cube = SDFCube::Create(float3(0.0f, 2.5f, 0.0f), float3(15.0f, 3.0f, 20.0f)).Evaluate(worldPosition);
    float4 sphere0 = SDFSphere::Create(float3(0.0f, 2.5f, 0.0f), 2.0f).Evaluate(worldPosition);
    float4 sphere1 = SDFSphere::Create(float3(0.0f, 2.5f, 0.0f), 5.0f).Evaluate(worldPosition);
    float4 height = GenerateHeight(worldPosition);

    float4 value_gradient = Union(sphere0, Difference(SmoothUnion(height, cube, 2.0f), sphere1));

    voxelVolume[CalculateVoxelVolumeIndex(voxelID)] = Voxel::Create(value_gradient.x, value_gradient.yzw);
}
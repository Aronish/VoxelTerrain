#pragma kernel GenerateFlatVertices
#pragma kernel GenerateSharpVertices

// If the marching cubes algorithm generates vertices for each voxel independently, many duplicate vertices will be generated.
// To avoid this for this cubical marching squares implementation we use the same approach as described in
// https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu
// to first generate the marching cubes edge (here called flat) vertices for the entire volume in kernel 0 and then
// generating the remaining (here called sharp) vertices in kernel 1. A lookup structured buffer is used to retrieve
// the flat vertices generated in kernel 0 from kernel 1 (see link, specifically "Generating a Block: Method 3").

#include "Include/CubicalMarchingSquares/Component.hlsl"
#include "Include/CubicalMarchingSquares/Flags.hlsl"
#include "Include/CubicalMarchingSquares/MarchingSquares.hlsl"
#include "Include/CubicalMarchingSquares/Segment.hlsl"
#include "Include/CubicalMarchingSquares/Voxel.hlsl"

#include "Include/HermiteSample.hlsl"
#include "Include/HermiteVolume.hlsl"
#include "Include/Vertex.hlsl"
#include "Include/VoxelVolume.hlsl"

static const uint3 voxelEdgeIndicesForFlatVertexGeneration = uint3(0, 3, 8);

// Convenience struct, instances of which act as entries into the lookup structured buffer described above.
struct VoxelFlatVertexIndices
{
    uint3 vertexIndices;

    uint GetFlatVertexIndex(uint index)
    {
        return vertexIndices[index];
    }

    void SetFlatVertexIndex(uint index, uint vertexIndex)
    {
        vertexIndices[index] = vertexIndex;
    }
};

VoxelFlatVertexIndices VoxelFlatVertexIndicesConstructor(uint edge0VertexIndex = -1, uint edge3VertexIndex = -1, uint edge8VertexIndex = -1)
{
    VoxelFlatVertexIndices voxelFlatVertexIndices;
    voxelFlatVertexIndices.vertexIndices = uint3(edge0VertexIndex, edge3VertexIndex, edge8VertexIndex);

    return voxelFlatVertexIndices;
}

float sharpFeatureAngle;
uint maxIterations;
float stepSize;

RWStructuredBuffer<Vertex> generatedVertices;
RWStructuredBuffer<VoxelFlatVertexIndices> flatVertexIndicesLookup;
AppendStructuredBuffer<uint3> generatedTriangles;

static Segment segments[maxSegmentsCount];
static Component components[maxComponentsCount];
static float3 forces[voxelCornersCount];

uint GenerateFlatFeatureVertex(uint3 voxelID, VoxelEdge edge)
{

    uint3 voxelCornerA = voxelCorners[edge.GetVoxelCornerStartIndex()];
    uint3 voxelCornerB = voxelCorners[edge.GetVoxelCornerEndIndex()];

    uint3 hermiteIDA = voxelID + voxelCornerA;
    uint3 hermiteIDB = voxelID + voxelCornerB;

    if (IsOutOfHermiteBounds(hermiteIDA) || IsOutOfHermiteBounds(hermiteIDB))
    {
        return - 1;
    }

    HermiteSample sampleA = hermiteVolume[CalculateHermiteIndex(hermiteIDA)];
    HermiteSample sampleB = hermiteVolume[CalculateHermiteIndex(hermiteIDB)];

    if (sampleA.GetValue() < 0.0f == sampleB.GetValue() < 0.0f)
    {
        return - 1;
    }

    float interpolant = -sampleA.GetValue() / (sampleB.GetValue() - sampleA.GetValue());

    uint vertexIndex = generatedVertices.IncrementCounter();

    generatedVertices[vertexIndex] = VertexConstructor
    (
        VoxelToVoxelVolumeSpace(voxelID, lerp(voxelCornerA, voxelCornerB, interpolant)),
        normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
    );

    return vertexIndex;
}

[numthreads(4, 4, 4)]
void GenerateFlatVertices(uint3 voxelID: SV_DispatchThreadID)
{
    if (IsOutOfHermiteBounds(voxelID))
    {
        return;
    }

    VoxelFlatVertexIndices voxelFlatVertexIndices = VoxelFlatVertexIndicesConstructor();

    [unroll]
    for (uint index = 0; index < 3; index++)
    {
        uint edgeIndex = voxelEdgeIndicesForFlatVertexGeneration[index];
        uint vertexIndex = GenerateFlatFeatureVertex(voxelID, voxelEdges[edgeIndex]);
        voxelFlatVertexIndices.SetFlatVertexIndex(index, vertexIndex);
    }

    flatVertexIndicesLookup[CalculateHermiteIndex(voxelID)] = voxelFlatVertexIndices;
}

uint GetFlatFeatureVertexIndex(uint3 voxelID, uint edgeIndex)
{
    // For certain edges of the current voxel we need to look into adjacent
    // voxels to find the corresponding flat vertex index. This relationship
    // between edge and corresponding flat vertex index is mapped in the array
    // right below.
    const uint4 edgeIndexToFlatVertexIndexMapping[12] = {
        uint4(0, 0, 0, 0),
        uint4(1, 0, 0, 1),
        uint4(0, 0, 1, 0),
        uint4(0, 0, 0, 1),
        uint4(0, 1, 0, 0),
        uint4(1, 1, 0, 1),
        uint4(0, 1, 1, 0),
        uint4(0, 1, 0, 1),
        uint4(0, 0, 0, 2),
        uint4(1, 0, 0, 2),
        uint4(1, 0, 1, 2),
        uint4(0, 0, 1, 2)
    };

    uint4 mapping = edgeIndexToFlatVertexIndexMapping[edgeIndex];

    return flatVertexIndicesLookup[CalculateHermiteIndex(voxelID + mapping.xyz)].GetFlatVertexIndex(mapping.w);
}

uint2 GenerateFaceSharpFeatureVertices(uint3 voxelID, VoxelFace voxelFace, Vertex vertexA, Vertex vertexB)
{
    if (acos(dot(vertexA.normal, vertexB.normal)) < sharpFeatureAngle)
    {
        return - 1;
    }

    float3 faceTangentA = voxelFace.GetFaceTangent(vertexA.normal);
    float3 faceTangentB = voxelFace.GetFaceTangent(vertexB.normal);
    
    float3 lineVec3 = vertexB.position - vertexA.position;
    float3 crossVec1and2 = cross(faceTangentA, faceTangentB);
    float3 crossVec3and2 = cross(lineVec3, faceTangentB);
    float s = dot(crossVec3and2, crossVec1and2) / dot(crossVec1and2, crossVec1and2);
    float3 sharpFeaturePosition = vertexA.position + (faceTangentA * s);

    // A single segment sharp feature is shared between exactly two segments, one segment belonging to the current voxel
    // and the other belonging to the adjacent voxel sharing the same voxel face. Therefore the position of the sharp feature
    // will be independently calculated twice. Due to floating point errors both calculated sharp feature positions can be
    // slightly different. This can result in one of both being "outside" the voxel while the other one isn't.
    // To compensate for this potential discrepancy a small value (epsilon) is added to the extents of the voxel for the check.
    if (IsOutsideVoxel(VoxelVolumeToVoxelSpace(voxelID, sharpFeaturePosition), 1e-4f) || any(isnan(sharpFeaturePosition)))
    {
        return - 1;
    }

    uint2 indices = uint2(generatedVertices.IncrementCounter(), generatedVertices.IncrementCounter());

    generatedVertices[indices.x] = VertexConstructor(sharpFeaturePosition, vertexA.normal);
    generatedVertices[indices.y] = VertexConstructor(sharpFeaturePosition, vertexB.normal);

    return indices;
}

uint GenerateFaceSegments(uint3 voxelID, VoxelFace voxelFace, uint segmentsCount)
{
    uint segmentsIndex = 0;
    
    for (uint sampleIndex = 0; sampleIndex < 4; sampleIndex++)
    {
        uint3 hermiteID = voxelID + voxelCorners[voxelFace.voxelCornerIndices[sampleIndex]];
        HermiteSample sample = hermiteVolume[CalculateHermiteIndex(hermiteID)];
        segmentsIndex |= (sample.GetValue() < 0.0f) << sampleIndex;
    }

    uint4 faceSegments = marchingSquaresSegments[segmentsIndex];

    for (uint faceSegmentsIndex = 0; faceSegmentsIndex < 4; faceSegmentsIndex += 2)
    {
        if (faceSegments[faceSegmentsIndex] == -1)
        {
            break;
        }

        uint edgeIndexA = voxelFace.voxelEdgeIndices[faceSegments[faceSegmentsIndex + 0]];
        uint edgeIndexB = voxelFace.voxelEdgeIndices[faceSegments[faceSegmentsIndex + 1]];

        uint vertexIndexA = GetFlatFeatureVertexIndex(voxelID, edgeIndexA);
        uint vertexIndexB = GetFlatFeatureVertexIndex(voxelID, edgeIndexB);

        Vertex vertexA = generatedVertices[vertexIndexA];
        Vertex vertexB = generatedVertices[vertexIndexB];
        
        Segment segment = SegmentConstructor
        (
            edgeIndexA,
            vertexIndexA,
            edgeIndexB,
            vertexIndexB,
            GenerateFaceSharpFeatureVertices(voxelID, voxelFace, vertexA, vertexB)
        );

        segments[segmentsCount++] = segment;
    }
    return segmentsCount;
}

uint TraceComponents(uint segmentsCount)
{
    for (uint componentsIndex = 0; componentsIndex < maxComponentsCount; componentsIndex++)
    {
        components[componentsIndex] = ComponentConstructor();
    }

    Flags segmentsAssigned = BitFlagConstructor();
    uint componentsCount = 0;
    uint segmentsIndex = -1;
    uint remainingSegmentsToAssign = segmentsCount;

    while(remainingSegmentsToAssign > 0)
    {
        segmentsIndex = (segmentsIndex + 1) % segmentsCount;

        if (segmentsAssigned.HasFlag(segmentsIndex))
        {
            continue;
        }

        uint componentLength = 0;
        uint start = segments[segmentsIndex].GetEdgeIndexA();
        uint end = segments[segmentsIndex].GetEdgeIndexB();
        segmentsAssigned.SetFlag(segmentsIndex);
        components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
        componentLength++;
        remainingSegmentsToAssign--;

        while(start != end)
        {
            segmentsIndex = (segmentsIndex + 1) % segmentsCount;

            if (segmentsAssigned.HasFlag(segmentsIndex))
            {
                continue;
            }

            Segment segment = segments[segmentsIndex];

            if (end == segment.GetEdgeIndexA() || end == segment.GetEdgeIndexB())
            {
                bool flipped = end == segment.GetEdgeIndexB();

                if (flipped)
                {
                    segments[segmentsIndex].SwapEdges();
                }

                end = segments[segmentsIndex].GetEdgeIndexB();
                segmentsAssigned.SetFlag(segmentsIndex);
                components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
                componentLength++;
                remainingSegmentsToAssign--;
            }
        }
        components[componentsCount].SetLength(componentLength);
        componentsCount++;
    }
    return componentsCount;
}

Vertex CalculateCenterVertex(Component component)
{
    Vertex centerVertex = VertexConstructor();

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];
        Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
        centerVertex.position += vertex.position;
        centerVertex.normal += vertex.normal;
    }

    centerVertex.position /= index;
    centerVertex.normal = normalize(centerVertex.normal);

    return centerVertex;
}

bool HasSharpFeature(Component component)
{
    float cosOfAngle = 1.0f;

    for (uint indexA = 0; indexA < component.GetLength(); indexA++)
    {
        Segment segmentA = segments[component.GetPackedSegmentsIndex(indexA)];
        Vertex vertexA = generatedVertices[segmentA.GetEdgeVertexIndexA()];

        for (uint indexB = 0; indexB < component.GetLength(); indexB++)
        {
            Segment segmentB = segments[component.GetPackedSegmentsIndex(indexB)];
            Vertex vertexB = generatedVertices[segmentB.GetEdgeVertexIndexA()];
            float newCosOfAngle = dot(vertexA.normal, vertexB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle: cosOfAngle;
        }
    }
    return acos(cosOfAngle) >= sharpFeatureAngle;
}

void CalculateForces(Component component)
{
    for (uint cornerIndex = 0; cornerIndex < voxelCornersCount; cornerIndex++)
    {
        forces[cornerIndex] = 0.0f;

        for (uint index = 0; index < component.GetLength(); index++)
        {
            Segment segment = segments[component.GetPackedSegmentsIndex(index)];
            Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
            float distance = dot(vertex.normal, voxelCorners[cornerIndex] - vertex.position);
            forces[cornerIndex] -= distance * vertex.normal;
        }
    }
}

float3 CalculateCombinedForce(float3 alpha_beta_gamma)
{
    float3 force03 = (1.0f - alpha_beta_gamma.x) * forces[0] + alpha_beta_gamma.x * forces[3];
    float3 force12 = (1.0f - alpha_beta_gamma.x) * forces[1] + alpha_beta_gamma.x * forces[2];
    float3 force47 = (1.0f - alpha_beta_gamma.x) * forces[4] + alpha_beta_gamma.x * forces[7];
    float3 force56 = (1.0f - alpha_beta_gamma.x) * forces[5] + alpha_beta_gamma.x * forces[6];

    float3 force0347 = (1.0f - alpha_beta_gamma.y) * force03 + alpha_beta_gamma.y * force47;
    float3 force1256 = (1.0f - alpha_beta_gamma.y) * force12 + alpha_beta_gamma.y * force56;

    return(1.0f - alpha_beta_gamma.z) * force0347 + alpha_beta_gamma.z * force1256;
}

Vertex CalculateComponentFeatureVertex(uint3 voxelID, Component component, out bool isComponentSharpFeature)
{
    Vertex featureVertex = CalculateCenterVertex(component);

    isComponentSharpFeature = HasSharpFeature(component);

    if (isComponentSharpFeature)
    {
        CalculateForces(component);

        for (uint iterations = 0; iterations < maxIterations; iterations++)
        {
            featureVertex.position += stepSize * CalculateCombinedForce(featureVertex.position.zyx);
        }
    }
    featureVertex.position = VoxelToVoxelVolumeSpace(voxelID, ClampToVoxel(VoxelVolumeToVoxelSpace(voxelID, featureVertex.position), 1e-3f));
    
    return featureVertex;
}

void GenerateTriangle(uint componentFeatureVertex, bool isComponentSharpFeature, uint segmentVertexIndex0, uint segmentVertexIndex1)
{
    if (isComponentSharpFeature)
    {
        Vertex componentSharpFeatureVertex = generatedVertices[componentFeatureVertex];
        Vertex segmentVertex0 = generatedVertices[segmentVertexIndex0];
        Vertex segmentVertex1 = generatedVertices[segmentVertexIndex1];

        float3 normal = normalize(cross(segmentVertex0.position - componentSharpFeatureVertex.position, segmentVertex1.position - componentSharpFeatureVertex.position));

        generatedVertices[componentFeatureVertex].normal = normal;
    }

    generatedTriangles.Append(uint3(componentFeatureVertex, segmentVertexIndex0, segmentVertexIndex1));
}

void GenerateTriangles(Component component, Vertex componentFeatureVertex, bool isComponentSharpFeature)
{
    uint componentFeatureVertexIndex = -1;

    if (!isComponentSharpFeature)
    {
        componentFeatureVertexIndex = generatedVertices.IncrementCounter();
        generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
    }

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];

        if (segment.HasSharpFeature())
        {
            if (isComponentSharpFeature)
            {
                componentFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            }
            GenerateTriangle(componentFeatureVertexIndex, isComponentSharpFeature, segment.GetSharpFeatureVertexIndexA(), segment.GetEdgeVertexIndexA());

            if (isComponentSharpFeature)
            {
                componentFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            }
            GenerateTriangle(componentFeatureVertexIndex, isComponentSharpFeature, segment.GetEdgeVertexIndexB(), segment.GetSharpFeatureVertexIndexB());
        }
        else
        {
            if (isComponentSharpFeature)
            {
                componentFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            }
            GenerateTriangle(componentFeatureVertexIndex, isComponentSharpFeature, segment.GetEdgeVertexIndexB(), segment.GetEdgeVertexIndexA());
        }
    }
}

[numthreads(4, 4, 4)]
void GenerateSharpVertices(uint3 voxelID: SV_DispatchThreadID)
{
    if (IsOutOfVoxelBounds(voxelID))
    {
        return;
    }

    uint segmentsCount = 0;

    for (uint faceIndex = 0; faceIndex < voxelFacesCount; faceIndex++)
    {
        segmentsCount = GenerateFaceSegments(voxelID, voxelFaces[faceIndex], segmentsCount);
    }

    if (segmentsCount == 0)
    {
        return;
    }

    uint componentsCount = TraceComponents(segmentsCount);
    
    for (uint componentsIndex = 0; componentsIndex < componentsCount; componentsIndex++)
    {
        bool isComponentSharpFeature;
        Vertex componentFeatureVertex = CalculateComponentFeatureVertex(voxelID, components[componentsIndex], isComponentSharpFeature);
        GenerateTriangles(components[componentsIndex], componentFeatureVertex, isComponentSharpFeature);
    }
}
#pragma kernel GenerateMesh

#include "Include/CubicalMarchingSquares/Component.hlsl"
#include "Include/CubicalMarchingSquares/Flags.hlsl"
#include "Include/CubicalMarchingSquares/MarchingSquares.hlsl"
#include "Include/CubicalMarchingSquares/Segment.hlsl"
#include "Include/CubicalMarchingSquares/Voxel.hlsl"

#include "Include/HermiteSample.hlsl"
#include "Include/HermiteVolume.hlsl"
#include "Include/VoxelVolume.hlsl"
#include "Include/Vertex.hlsl"

float sharpFeatureAngle;
uint maxIterations;
float stepSize;

RWStructuredBuffer<Vertex> generatedVertices;
AppendStructuredBuffer<uint3> generatedTriangles;

static Segment segments[maxSegmentsCount];
static Component components[maxComponentsCount];
static float3 forces[voxelCornersCount];

Vertex CalculateVertexAlongVoxelEdge(uint3 voxelID, VoxelEdge edge)
{
    uint3 voxelCornerA = voxelCorners[edge.GetVoxelCornerStartIndex()];
    uint3 voxelCornerB = voxelCorners[edge.GetVoxelCornerEndIndex()];

    HermiteSample sampleA = hermiteVolume[CalculateHermiteIndex(voxelStride * (voxelID + voxelCornerA))];
    HermiteSample sampleB = hermiteVolume[CalculateHermiteIndex(voxelStride * (voxelID + voxelCornerB))];

    float interpolant = -sampleA.GetValue() / (sampleB.GetValue() - sampleA.GetValue());

    return VertexConstructor
    (
        VoxelToVoxelVolumeSpace(voxelID, lerp(voxelCornerA, voxelCornerB, interpolant)),
        normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
    );
}

uint2 GenerateSharpFeatureVertices(uint3 voxelID, VoxelFace voxelFace, Vertex vertexA, Vertex vertexB)
{
    if (acos(dot(vertexA.normal, vertexB.normal)) < sharpFeatureAngle)
    {
        return - 1;
    }

    float3 faceTangentA = voxelFace.GetFaceTangent(vertexA.normal);
    float3 faceTangentB = voxelFace.GetFaceTangent(vertexB.normal);
    
    float3 lineVec3 = vertexB.position - vertexA.position;
    float3 crossVec1and2 = cross(faceTangentA, faceTangentB);
    float3 crossVec3and2 = cross(lineVec3, faceTangentB);
    float s = dot(crossVec3and2, crossVec1and2) / dot(crossVec1and2, crossVec1and2);
    float3 sharpFeaturePosition = vertexA.position + (faceTangentA * s);

    // A single segment sharp feature is shared between exactly two segments, one segment belonging to the current voxel
    // and the other belonging to the adjacent voxel sharing the same voxel face. Therefore the position of the sharp feature
    // will be independently calculated twice. Due to floating point errors both calculated sharp feature positions can be
    // slightly different. This can result in one of both being "outside" the voxel while the other one isn't.
    // To compensate for this potential discrepancy a small value (epsilon) is added to the extents of the voxel for the check.
    if (IsOutsideVoxel(VoxelVolumeToVoxelSpace(voxelID, sharpFeaturePosition), 0.75f) || any(isnan(sharpFeaturePosition)))
    {
        return - 1;
    }

    uint2 indices = uint2(generatedVertices.IncrementCounter(), generatedVertices.IncrementCounter());

    Vertex sharpFeatureVertex = VertexConstructor(sharpFeaturePosition, 0.5f * (vertexA.normal + vertexB.normal));

    generatedVertices[indices.x] = sharpFeatureVertex;
    generatedVertices[indices.y] = sharpFeatureVertex;

    return indices;
}

uint GenerateFaceSegments(uint3 voxelID, VoxelFace voxelFace, uint segmentsCount)
{
    uint segmentsIndex = 0;
    
    for (uint sampleIndex = 0; sampleIndex < 4; sampleIndex++)
    {
        uint3 hermiteID = voxelStride * (voxelID + voxelCorners[voxelFace.voxelCornerIndices[sampleIndex]]);
        HermiteSample sample = hermiteVolume[CalculateHermiteIndex(hermiteID)];
        segmentsIndex |= (sample.GetValue() < 0.0f) << sampleIndex;
    }

    uint4 faceSegments = marchingSquaresSegments[segmentsIndex];

    for (uint faceSegmentsIndex = 0; faceSegmentsIndex < 4; faceSegmentsIndex += 2)
    {
        if (faceSegments[faceSegmentsIndex] == -1)
        {
            break;
        }

        uint edgeIndexA = voxelFace.voxelEdgeIndices[faceSegments[faceSegmentsIndex + 0]];
        uint edgeIndexB = voxelFace.voxelEdgeIndices[faceSegments[faceSegmentsIndex + 1]];

        VoxelEdge voxelEdgeA = voxelEdges[edgeIndexA];
        VoxelEdge voxelEdgeB = voxelEdges[edgeIndexB];

        Vertex vertexA = CalculateVertexAlongVoxelEdge(voxelID, voxelEdgeA);
        Vertex vertexB = CalculateVertexAlongVoxelEdge(voxelID, voxelEdgeB);
        
        Segment segment = SegmentConstructor
        (
            edgeIndexA,
            generatedVertices.IncrementCounter(),
            edgeIndexB,
            generatedVertices.IncrementCounter(),
            GenerateSharpFeatureVertices(voxelID, voxelFace, vertexA, vertexB)
        );

        generatedVertices[segment.GetEdgeVertexIndexA()] = vertexA;
        generatedVertices[segment.GetEdgeVertexIndexB()] = vertexB;
        
        segments[segmentsCount++] = segment;
    }
    return segmentsCount;
}

uint TraceComponents(uint segmentsCount)
{
    for (uint componentsIndex = 0; componentsIndex < maxComponentsCount; componentsIndex++)
    {
        components[componentsIndex] = ComponentConstructor();
    }

    Flags segmentsAssigned = BitFlagConstructor();
    uint componentsCount = 0;
    uint segmentsIndex = -1;
    uint remainingSegmentsToAssign = segmentsCount;

    while(remainingSegmentsToAssign > 0)
    {
        segmentsIndex = (segmentsIndex + 1) % segmentsCount;

        if (segmentsAssigned.HasFlag(segmentsIndex))
        {
            continue;
        }

        uint componentLength = 0;
        uint start = segments[segmentsIndex].GetEdgeIndexA();
        uint end = segments[segmentsIndex].GetEdgeIndexB();
        segmentsAssigned.SetFlag(segmentsIndex);
        components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
        componentLength++;
        remainingSegmentsToAssign--;

        while(start != end)
        {
            segmentsIndex = (segmentsIndex + 1) % segmentsCount;

            if (segmentsAssigned.HasFlag(segmentsIndex))
            {
                continue;
            }

            Segment segment = segments[segmentsIndex];

            if (end == segment.GetEdgeIndexA() || end == segment.GetEdgeIndexB())
            {
                bool flipped = end == segment.GetEdgeIndexB();

                if (flipped)
                {
                    segments[segmentsIndex].SwapEdges();
                }

                end = segments[segmentsIndex].GetEdgeIndexB();
                segmentsAssigned.SetFlag(segmentsIndex);
                components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
                componentLength++;
                remainingSegmentsToAssign--;
            }
        }
        components[componentsCount].SetLength(componentLength);
        componentsCount++;
    }
    return componentsCount;
}

Vertex CalculateCenterVertex(Component component)
{
    Vertex centerVertex = VertexConstructor();

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];
        Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
        centerVertex.position += vertex.position;
        centerVertex.normal += vertex.normal;
    }

    centerVertex.position /= index;
    centerVertex.normal = normalize(centerVertex.normal);

    return centerVertex;
}

bool HasSharpFeature(Component component)
{
    float cosOfAngle = 1.0f;

    for (uint indexA = 0; indexA < component.GetLength(); indexA++)
    {
        Segment segmentA = segments[component.GetPackedSegmentsIndex(indexA)];
        Vertex vertexA = generatedVertices[segmentA.GetEdgeVertexIndexA()];

        for (uint indexB = 0; indexB < component.GetLength(); indexB++)
        {
            Segment segmentB = segments[component.GetPackedSegmentsIndex(indexB)];
            Vertex vertexB = generatedVertices[segmentB.GetEdgeVertexIndexA()];
            float newCosOfAngle = dot(vertexA.normal, vertexB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle: cosOfAngle;
        }
    }
    return acos(cosOfAngle) >= sharpFeatureAngle;
}

void CalculateForces(Component component)
{
    for (uint cornerIndex = 0; cornerIndex < voxelCornersCount; cornerIndex++)
    {
        forces[cornerIndex] = 0.0f;

        for (uint index = 0; index < component.GetLength(); index++)
        {
            Segment segment = segments[component.GetPackedSegmentsIndex(index)];
            Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
            float distance = dot(vertex.normal, voxelCorners[cornerIndex] - vertex.position);
            forces[cornerIndex] -= distance * vertex.normal;
        }
    }
}

float3 CalculateCombinedForce(float3 alpha_beta_gamma)
{
    float3 force03 = (1.0f - alpha_beta_gamma.x) * forces[0] + alpha_beta_gamma.x * forces[3];
    float3 force12 = (1.0f - alpha_beta_gamma.x) * forces[1] + alpha_beta_gamma.x * forces[2];
    float3 force47 = (1.0f - alpha_beta_gamma.x) * forces[4] + alpha_beta_gamma.x * forces[7];
    float3 force56 = (1.0f - alpha_beta_gamma.x) * forces[5] + alpha_beta_gamma.x * forces[6];

    float3 force0347 = (1.0f - alpha_beta_gamma.y) * force03 + alpha_beta_gamma.y * force47;
    float3 force1256 = (1.0f - alpha_beta_gamma.y) * force12 + alpha_beta_gamma.y * force56;

    return(1.0f - alpha_beta_gamma.z) * force0347 + alpha_beta_gamma.z * force1256;
}

Vertex CalculateFeatureVertex(uint3 voxelID, Component component)
{
    Vertex featureVertex = CalculateCenterVertex(component);

    if (HasSharpFeature(component))
    {
        CalculateForces(component);

        for (uint iterations = 0; iterations < maxIterations; iterations++)
        {
            featureVertex.position += stepSize * CalculateCombinedForce(featureVertex.position.zyx);
        }
    }
    featureVertex.position = VoxelToVoxelVolumeSpace(voxelID, ClampToVoxel(VoxelVolumeToVoxelSpace(voxelID, featureVertex.position), 1e-1f));
    
    return featureVertex;
}

void GenerateTriangles(Component component, Vertex componentFeatureVertex)
{
    uint componentFeatureVertexIndex;

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];

        if (segment.GetSharpFeatureVertexIndexA() != -1)
        {
            componentFeatureVertexIndex = generatedVertices.IncrementCounter();
            generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            generatedTriangles.Append(uint3(componentFeatureVertexIndex, segment.GetSharpFeatureVertexIndexA(), segment.GetEdgeVertexIndexA()));

            componentFeatureVertexIndex = generatedVertices.IncrementCounter();
            generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            generatedTriangles.Append(uint3(segment.GetSharpFeatureVertexIndexB(), componentFeatureVertexIndex, segment.GetEdgeVertexIndexB()));
        }
        else
        {
            componentFeatureVertexIndex = generatedVertices.IncrementCounter();
            generatedVertices[componentFeatureVertexIndex] = componentFeatureVertex;
            generatedTriangles.Append(uint3(componentFeatureVertexIndex, segment.GetEdgeVertexIndexB(), segment.GetEdgeVertexIndexA()));
        }
    }
}

[numthreads(4, 4, 4)]
void GenerateMesh(uint3 voxelID: SV_DispatchThreadID)
{
    if (IsOutOfVoxelBounds(voxelID))
    {
        return;
    }

    uint segmentsCount = 0;

    for (uint faceIndex = 0; faceIndex < voxelFacesCount; faceIndex++)
    {
        segmentsCount = GenerateFaceSegments(voxelID, voxelFaces[faceIndex], segmentsCount);
    }

    if (segmentsCount == 0)
    {
        return;
    }

    uint componentsCount = TraceComponents(segmentsCount);
    
    for (uint componentsIndex = 0; componentsIndex < componentsCount; componentsIndex++)
    {
        GenerateTriangles(components[componentsIndex], CalculateFeatureVertex(voxelID, components[componentsIndex]));
    }
}
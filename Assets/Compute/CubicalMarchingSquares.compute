#pragma kernel GenerateMesh
#pragma multi_compile FLAT_SHADING __

#include "Assets/Compute/Include/CubicalMarchingSquares.cginc"
#include "Assets/Compute/Include/Vertex.cginc"
#include "Assets/Compute/Include/VoxelVolume.cginc"

uint subSampleChunkFaces;
float sharpFeatureAngle;
uint maxIterations;
float stepSize;

RWStructuredBuffer<Vertex> generatedVertices;
AppendStructuredBuffer<uint3> generatedTriangles;

Vertex CalculateVertexAlongEdge(uint3 id, uint2 edge)
{
    Vertex edgeVertex;

    uint3 cornerA = voxelCorners[edge[0]];
    uint3 cornerB = voxelCorners[edge[1]];

    HermiteData sampleA = hermiteVolume[CalculateHermiteIndex(voxelStride * (id + cornerA))];
    HermiteData sampleB = hermiteVolume[CalculateHermiteIndex(voxelStride * (id + cornerB))];

    float interpolant = -GetHermiteDataDensity(sampleA) / (GetHermiteDataDensity(sampleB) - GetHermiteDataDensity(sampleA));

    edgeVertex.position = lerp(cornerA, cornerB, interpolant);
    edgeVertex.normal = normalize(lerp(GetHermiteDataGradient(sampleA), GetHermiteDataGradient(sampleB), interpolant));

    return edgeVertex;
}

Vertex CalculateSegmentSharpFeatureVertex(Vertex edgeVertexA, float3 planeTangentA, Vertex edgeVertexB, float3 planeTangentB)
{
    Vertex sharpFeatureVertex;

    float3 lineVec3 = edgeVertexB.position - edgeVertexA.position;
    float3 crossVec1and2 = cross(planeTangentA, planeTangentB);
    float3 crossVec3and2 = cross(lineVec3, planeTangentB);
    float s = dot(crossVec3and2, crossVec1and2) / dot(crossVec1and2, crossVec1and2);
    float3 faceSharpFeaturePosition = edgeVertexA.position + (planeTangentA * s);

    sharpFeatureVertex.position = ClampPositionToVoxel(faceSharpFeaturePosition);
    sharpFeatureVertex.normal = normalize(edgeVertexA.normal + edgeVertexB.normal);

    return sharpFeatureVertex;
}

void GenerateTriangle(uint3 id, uint vertexAIndex, uint vertexBIndex, uint vertexCIndex, bool hasSharpFeature)
{
    Vertex vertexA = generatedVertices[vertexAIndex];
    Vertex vertexB = generatedVertices[vertexBIndex];
    Vertex vertexC = generatedVertices[vertexCIndex];

    uint3 indices = uint3(vertexAIndex, vertexBIndex, vertexCIndex);

    float3 localPosition = CalculateLocalPosition(id);

    vertexA.position = voxelStride * voxelSpacing * vertexA.position + localPosition;
    vertexB.position = voxelStride * voxelSpacing * vertexB.position + localPosition;
    vertexC.position = voxelStride * voxelSpacing * vertexC.position + localPosition;

    float3 normal = -normalize(cross(vertexB.position - vertexA.position, vertexC.position - vertexA.position));

#ifdef FLAT_SHADING
    vertexA.normal = normal;
    vertexB.normal = normal;
    vertexC.normal = normal;
#else
    if (hasSharpFeature)
    {
        vertexA.normal = normal;
        vertexC.normal = normal;
    }
#endif

    generatedVertices[vertexAIndex] = vertexA;
    generatedVertices[vertexBIndex] = vertexB;
    generatedVertices[vertexCIndex] = vertexC;

    generatedTriangles.Append(indices.xzy);
}

[numthreads(4, 4, 4)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    if (IsOutOfVoxelBounds(id))
    {
        return;
    }

    Segment segments[12];
    uint segmentsCount = 0;

    for (uint faceIndex = 0; faceIndex < 6; faceIndex++)
    {
        // >>> Calculate face segments.
        uint4 faceSampleIndices = voxelFaceSampleIndices[faceIndex];
        uint segmentsIndex = 0;

        for (uint sampleIndex = 0; sampleIndex < 4; sampleIndex++)
        {
            uint3 position = voxelStride * (id + voxelCorners[faceSampleIndices[sampleIndex]]);
            HermiteData sample = hermiteVolume[CalculateHermiteIndex(position)];
            segmentsIndex |= (GetHermiteDataDensity(sample) >= 0.0) << sampleIndex;
        }

        uint4 face = voxelFaces[faceIndex];
        uint4 faceSegments = marchingSquaresSegments[segmentsIndex];

        for (uint faceSegmentsIndex = 0; faceSegmentsIndex < 4; faceSegmentsIndex += 2)
        {
            if (faceSegments[faceSegmentsIndex] == -1)
            {
                break;
            }

            uint edgeIndexA = face[faceSegments[faceSegmentsIndex + 0]];
            uint edgeIndexB = face[faceSegments[faceSegmentsIndex + 1]];

            uint2 voxelEdgeA = voxelEdges[edgeIndexA];
            uint2 voxelEdgeB = voxelEdges[edgeIndexB];

            Vertex edgeVertexA = CalculateVertexAlongEdge(id, voxelEdgeA);
            Vertex edgeVertexB = CalculateVertexAlongEdge(id, voxelEdgeB);

            float3 planeTangentA = normalize(mul(normalToFaceTangentMatrices[faceIndex], edgeVertexA.normal));
            float3 planeTangentB = normalize(mul(normalToFaceTangentMatrices[faceIndex], edgeVertexB.normal));
            Vertex sharpFeatureVertex = CalculateSegmentSharpFeatureVertex(edgeVertexA, planeTangentA, edgeVertexB, planeTangentB);

            Segment segment;
            InitializeSegment
            (
                segment, 
                edgeIndexA, 
                generatedVertices.IncrementCounter(), 
                edgeIndexB, 
                generatedVertices.IncrementCounter(),
                acos(dot(edgeVertexA.normal, edgeVertexB.normal)) >= sharpFeatureAngle ? uint2(generatedVertices.IncrementCounter(), generatedVertices.IncrementCounter()) : -1
            );
            segments[segmentsCount++] = segment;

            generatedVertices[GetEdgeVertexIndexA(segment)] = edgeVertexA;
            generatedVertices[GetEdgeVertexIndexB(segment)] = edgeVertexB;

            if (GetSharpFeatureVertexIndexA(segment) != -1)
            {
                generatedVertices[GetSharpFeatureVertexIndexA(segment)] = sharpFeatureVertex;
                generatedVertices[GetSharpFeatureVertexIndexB(segment)] = sharpFeatureVertex;
            }
        }
        // <<<
    }

    if (segmentsCount == 0)
    {
        return;
    }

    Component components[4];
    uint componentIndex;

    // >>> Trace components.
    for (componentIndex = 0; componentIndex < 4; componentIndex++)
    {
        InitializeComponent(components[componentIndex]);
    }

    Flags segmentsAssigned;
    InitializeBitFlag(segmentsAssigned);

    uint componentsCount = 0;
    uint segmentsIndex = -1;
    uint remainingSegmentsToAssign = segmentsCount;

    while (remainingSegmentsToAssign > 0)
    {
        segmentsIndex = (segmentsIndex + 1) % segmentsCount;

        if (HasFlag(segmentsAssigned, segmentsIndex))
        {
            continue;
        }

        uint componentLength = 0;
        uint start = GetEdgeIndexA(segments[segmentsIndex]);
        uint end = GetEdgeIndexB(segments[segmentsIndex]);
        SetFlag(segmentsAssigned, segmentsIndex);
        SetPackedSegmentIndex(components[componentsCount].packedSegmentIndices, componentLength, segmentsIndex);
        componentLength++;
        remainingSegmentsToAssign--;

        while (start != end)
        {
            segmentsIndex = (segmentsIndex + 1) % segmentsCount;

            if (HasFlag(segmentsAssigned, segmentsIndex))
            {
                continue;
            }

            Segment segment = segments[segmentsIndex];

            if (end == GetEdgeIndexA(segment) || end == GetEdgeIndexB(segment))
            {
                bool flipped = end == GetEdgeIndexB(segment);

                if (flipped)
                {
                    SwapEdges(segments[segmentsIndex]);
                }

                end = GetEdgeIndexB(segments[segmentsIndex]);
                SetFlag(segmentsAssigned, segmentsIndex);
                SetPackedSegmentIndex(components[componentsCount].packedSegmentIndices, componentLength, segmentsIndex);
                componentLength++;
                remainingSegmentsToAssign--;
            }
        }
        SetComponentLength(components[componentsCount], componentLength);
        componentsCount++;
    }
    // <<<

    for (componentIndex = 0; componentIndex < componentsCount; componentIndex++)
    {
        Component component = components[componentIndex];

        // >>> Generate component sharp Feature.
        // >> Calculate component center vertex.
        Vertex componentSharpFeatureVertex;
        componentSharpFeatureVertex.position = 0;
        componentSharpFeatureVertex.normal = 0;

        uint index;

        for (index = 0; index < GetComponentLength(component); index++)
        {
            Segment segment = segments[GetPackedSegmentIndex(component, index)];
            Vertex edgeVertex = generatedVertices[GetEdgeVertexIndexA(segment)];
            
            if (IsOnVoxelEdge(edgeVertex.position))
            {
                componentSharpFeatureVertex.position += edgeVertex.position;
                componentSharpFeatureVertex.normal += edgeVertex.normal;
            }
        }

        componentSharpFeatureVertex.position /= index;
        componentSharpFeatureVertex.normal = normalize(componentSharpFeatureVertex.normal);
        // <<

        // >> Check for component sharp feature.
        float cosOfAngle = 1.0;

        for (uint indexA = 0; indexA < GetComponentLength(component); indexA++)
        {
            Segment segmentA = segments[GetPackedSegmentIndex(component, indexA)];
            Vertex edgeVertexA = generatedVertices[GetEdgeVertexIndexA(segmentA)];

            for (uint indexB = 0; indexB < GetComponentLength(component); indexB++)
            {
                Segment segmentB = segments[GetPackedSegmentIndex(component, indexB)];
                Vertex edgeVertexB = generatedVertices[GetEdgeVertexIndexA(segmentB)];
                
                if (IsOnVoxelEdge(edgeVertexA.position) && IsOnVoxelEdge(edgeVertexB.position))
                {
                    float newCosOfAngle = dot(edgeVertexA.normal, edgeVertexB.normal);
                    cosOfAngle = cosOfAngle > newCosOfAngle ? newCosOfAngle : cosOfAngle;
                }
            }
        }  
        bool hasComponentSharpFeature = acos(cosOfAngle) >= sharpFeatureAngle;
        // <<

        if (hasComponentSharpFeature)
        {
            // >> Calculate forces.
            float3 forces[8];

            for (uint cornerIndex = 0; cornerIndex < 8; cornerIndex++)
            {
                forces[cornerIndex] = 0.0;
                float3 corner = voxelCorners[cornerIndex];
                float3 force = 0;

                for (index = 0; index < GetComponentLength(component); index++)
                {
                    Segment segment = segments[GetPackedSegmentIndex(component, index)];
                    Vertex edgeVertex = generatedVertices[GetEdgeVertexIndexA(segment)];

                    if (IsOnVoxelEdge(edgeVertex.position))
                    {
                        float distance = dot(edgeVertex.normal, corner - edgeVertex.position);
                        forces[cornerIndex] -= distance * edgeVertex.normal;
                    }
                }
            }
            // <<

            // >> Calculate combined force and adjust component sharp feature vertex.
            for (uint iterations = 0; iterations < maxIterations; iterations++)
            {
                float alpha = componentSharpFeatureVertex.position.z;

                float3 force03 = (1.0 - alpha) * forces[0] + alpha * forces[3];
                float3 force12 = (1.0 - alpha) * forces[1] + alpha * forces[2];
                float3 force47 = (1.0 - alpha) * forces[4] + alpha * forces[7];
                float3 force56 = (1.0 - alpha) * forces[5] + alpha * forces[6];

                float beta = componentSharpFeatureVertex.position.y;

                float3 force0347 = (1.0 - beta) * force03 + beta * force47;
                float3 force1256 = (1.0 - beta) * force12 + beta * force56;

                float gamma = componentSharpFeatureVertex.position.x;

                float3 combinedForce = (1.0 - gamma) * force0347 + gamma * force1256;

                componentSharpFeatureVertex.position += stepSize * combinedForce;
                componentSharpFeatureVertex.position = ClampPositionToVoxel(componentSharpFeatureVertex.position);
            }
            // <<
        }
        // <<<

        // >>> Generate triangles.
        for (index = 0; index < GetComponentLength(component); index++)
        {
            Segment segment = segments[GetPackedSegmentIndex(component, index)];

            uint componentSharpFeatureVertexIndex = generatedVertices.IncrementCounter();
            generatedVertices[componentSharpFeatureVertexIndex] = componentSharpFeatureVertex;

            if (GetSharpFeatureVertexIndexA(segment) != -1)
            {
                GenerateTriangle
                (
                    id, 
                    componentSharpFeatureVertexIndex, 
                    GetEdgeVertexIndexA(segment), 
                    GetSharpFeatureVertexIndexA(segment), 
                    hasComponentSharpFeature
                );

                componentSharpFeatureVertexIndex = generatedVertices.IncrementCounter();
                generatedVertices[componentSharpFeatureVertexIndex] = componentSharpFeatureVertex;
                GenerateTriangle
                (
                    id,
                    GetSharpFeatureVertexIndexB(segment), 
                    GetEdgeVertexIndexB(segment), 
                    componentSharpFeatureVertexIndex, 
                    hasComponentSharpFeature
                );
            }
            else
            {
                GenerateTriangle
                (
                    id,
                    componentSharpFeatureVertexIndex,
                    GetEdgeVertexIndexA(segment),
                    GetEdgeVertexIndexB(segment),
                    hasComponentSharpFeature
                );
            }
        }
        // <<<
    }
}
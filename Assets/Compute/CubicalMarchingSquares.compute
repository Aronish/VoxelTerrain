#pragma kernel GenerateMesh
#pragma multi_compile FLAT_SHADING __

#include "Include/CubicalMarchingSquares/Component.hlsl"
#include "Include/CubicalMarchingSquares/Flags.hlsl"
#include "Include/CubicalMarchingSquares/MarchingSquares.hlsl"
#include "Include/CubicalMarchingSquares/Segment.hlsl"
#include "Include/CubicalMarchingSquares/Voxel.hlsl"

#include "Include/Vertex.hlsl"
#include "Include/VoxelVolume.hlsl"

uint subSampleChunkFaces;
float sharpFeatureAngle;
uint maxIterations;
float stepSize;

RWStructuredBuffer<Vertex> generatedVertices;
AppendStructuredBuffer<uint3> generatedTriangles;

static Segment segments[maxSegmentsCount];
static Component components[maxComponentsCount];
static float3 forces[voxelCornersCount];

Vertex CalculateVertexAlongVoxelEdge(uint3 id, VoxelEdge edge)
{
    uint3 voxelCornerA = voxelCorners[edge.GetVoxelCornerStartIndex()];
    uint3 voxelCornerB = voxelCorners[edge.GetVoxelCornerEndIndex()];

    HermiteSample sampleA = hermiteVolume[CalculateHermiteIndex(voxelStride * (id + voxelCornerA))];
    HermiteSample sampleB = hermiteVolume[CalculateHermiteIndex(voxelStride * (id + voxelCornerB))];

    float interpolant = -sampleA.GetDensity() / (sampleB.GetDensity() - sampleA.GetDensity());

    return VertexConstructor
    (
        lerp(voxelCornerA, voxelCornerB, interpolant),
        normalize(lerp(sampleA.GetGradient(), sampleB.GetGradient(), interpolant))
    );
}

uint2 GenerateSegmentSharpFeatureVertices(VoxelFace voxelFace, Vertex vertexA, Vertex vertexB)
{
    if (acos(dot(vertexA.normal, vertexB.normal)) < sharpFeatureAngle)
    {
        return -1;
    }

    float3 faceTangentA = voxelFace.GetFaceTangent(vertexA.normal);   
    float3 faceTangentB = voxelFace.GetFaceTangent(vertexB.normal);
    
    float3 lineVec3 = vertexB.position - vertexA.position;
    float3 crossVec1and2 = cross(faceTangentA, faceTangentB);
    float3 crossVec3and2 = cross(lineVec3, faceTangentB);
    float s = dot(crossVec3and2, crossVec1and2) / dot(crossVec1and2, crossVec1and2);
    float3 segmentSharpFeatureVertexPosition = vertexA.position + (faceTangentA * s);

    // A single segment sharp feature is shared between exactly two segments, one segment belonging to the current voxel
    // and the other belonging to the adjacent voxel sharing the same voxel face. Therefore the position of the sharp feature
    // will be independently calculated twice. Due to floating point errors both calculated sharp feature positions can be
    // slightly different. This can result in one of both being "outside" the voxel while the other one isn't.
    // To compensate for this potential discrepancy a small value (epsilon) is added to the extents of the voxel for the check.
    if (IsOutsideVoxel(segmentSharpFeatureVertexPosition, 1e-4f) || any(isnan(segmentSharpFeatureVertexPosition)))
    {
        return -1;
    }

    uint2 indices = uint2(generatedVertices.IncrementCounter(), generatedVertices.IncrementCounter());

    generatedVertices[indices.x] = VertexConstructor(segmentSharpFeatureVertexPosition, vertexA.normal);
    generatedVertices[indices.y] = VertexConstructor(segmentSharpFeatureVertexPosition, vertexB.normal);

    return indices;
}

uint GenerateFaceSegments(uint3 id, VoxelFace voxelFace, uint segmentsCount)
{
    uint segmentsIndex = 0;
    
    for (uint sampleIndex = 0; sampleIndex < 4; sampleIndex++)
    {
        uint3 position = voxelStride * (id + voxelCorners[voxelFace.voxelCornerIndices[sampleIndex]]);
        HermiteSample sample = hermiteVolume[CalculateHermiteIndex(position)];
        segmentsIndex |= (sample.GetDensity() < 0.0f) << sampleIndex;
    }

    uint4 faceSegments = marchingSquaresSegments[segmentsIndex];

    for (uint faceSegmentsIndex = 0; faceSegmentsIndex < 4; faceSegmentsIndex += 2)
    {
        if (faceSegments[faceSegmentsIndex] == -1)
        {
            break;
        }

        uint edgeIndexA = voxelFace.voxelEdgeIndices[faceSegments[faceSegmentsIndex + 0]];
        uint edgeIndexB = voxelFace.voxelEdgeIndices[faceSegments[faceSegmentsIndex + 1]];

        VoxelEdge voxelEdgeA = voxelEdges[edgeIndexA];
        VoxelEdge voxelEdgeB = voxelEdges[edgeIndexB];

        Vertex vertexA = CalculateVertexAlongVoxelEdge(id, voxelEdgeA);
        Vertex vertexB = CalculateVertexAlongVoxelEdge(id, voxelEdgeB);
        
        Segment segment = SegmentConstructor
        (
            edgeIndexA,
            generatedVertices.IncrementCounter(),
            edgeIndexB,
            generatedVertices.IncrementCounter(),
            GenerateSegmentSharpFeatureVertices(voxelFace, vertexA, vertexB)
        );

        generatedVertices[segment.GetEdgeVertexIndexA()] = vertexA;
        generatedVertices[segment.GetEdgeVertexIndexB()] = vertexB;
        
        segments[segmentsCount++] = segment;
    }
    return segmentsCount;
}

uint TraceComponents(uint segmentsCount)
{
    for (uint componentsIndex = 0; componentsIndex < maxComponentsCount; componentsIndex++)
    {
        components[componentsIndex] = ComponentConstructor();
    }

    Flags segmentsAssigned = BitFlagConstructor();
    uint componentsCount = 0;
    uint segmentsIndex = -1;
    uint remainingSegmentsToAssign = segmentsCount;

    while (remainingSegmentsToAssign > 0)
    {
        segmentsIndex = (segmentsIndex + 1) % segmentsCount;

        if (segmentsAssigned.HasFlag(segmentsIndex))
        {
            continue;
        }

        uint componentLength = 0;
        uint start = segments[segmentsIndex].GetEdgeIndexA();
        uint end = segments[segmentsIndex].GetEdgeIndexB();
        segmentsAssigned.SetFlag(segmentsIndex);
        components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
        componentLength++;
        remainingSegmentsToAssign--;

        while (start != end)
        {
            segmentsIndex = (segmentsIndex + 1) % segmentsCount;

            if (segmentsAssigned.HasFlag(segmentsIndex))
            {
                continue;
            }

            Segment segment = segments[segmentsIndex];

            if (end == segment.GetEdgeIndexA() || end == segment.GetEdgeIndexB())
            {
                bool flipped = end == segment.GetEdgeIndexB();

                if (flipped)
                {
                    segments[segmentsIndex].SwapEdges();
                }

                end = segments[segmentsIndex].GetEdgeIndexB();
                segmentsAssigned.SetFlag(segmentsIndex);
                components[componentsCount].SetPackedSegmentsIndex(componentLength, segmentsIndex);
                componentLength++;
                remainingSegmentsToAssign--;
            }
        }
        components[componentsCount].SetLength(componentLength);
        componentsCount++;
    }
    return componentsCount;
}

Vertex CalculateComponentCenterVertex(Component component)
{
    Vertex componentSharpFeatureVertex = VertexConstructor(0.0f, 0.0f);

    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];
        Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
        componentSharpFeatureVertex.position += vertex.position;
        componentSharpFeatureVertex.normal += vertex.normal;
    }

    componentSharpFeatureVertex.position /= index;
    componentSharpFeatureVertex.normal = normalize(componentSharpFeatureVertex.normal);

    return componentSharpFeatureVertex;
}

bool HasComponentSharpFeature(Component component)
{
    float cosOfAngle = 1.0f;

    for (uint indexA = 0; indexA < component.GetLength(); indexA++)
    {
        Segment segmentA = segments[component.GetPackedSegmentsIndex(indexA)];
        Vertex vertexA = generatedVertices[segmentA.GetEdgeVertexIndexA()];

        for (uint indexB = 0; indexB < component.GetLength(); indexB++)
        {
            Segment segmentB = segments[component.GetPackedSegmentsIndex(indexB)];
            Vertex vertexB = generatedVertices[segmentB.GetEdgeVertexIndexA()];
            float newCosOfAngle = dot(vertexA.normal, vertexB.normal);
            cosOfAngle = newCosOfAngle < cosOfAngle ? newCosOfAngle : cosOfAngle;
        }
    }
    return acos(cosOfAngle) >= sharpFeatureAngle;
}

void CalculateForces(Component component)
{
    for (uint cornerIndex = 0; cornerIndex < voxelCornersCount; cornerIndex++)
    {
        forces[cornerIndex] = 0.0f;

        for (uint index = 0; index < component.GetLength(); index++)
        {
            Segment segment = segments[component.GetPackedSegmentsIndex(index)];
            Vertex vertex = generatedVertices[segment.GetEdgeVertexIndexA()];
            float distance = dot(vertex.normal, voxelCorners[cornerIndex] - vertex.position);
            forces[cornerIndex] -= distance * vertex.normal;
        }
    }
}

float3 CalculateCombinedForce(float3 alpha_beta_gamma)
{
    float3 force03 = (1.0f - alpha_beta_gamma.x) * forces[0] + alpha_beta_gamma.x * forces[3];
    float3 force12 = (1.0f - alpha_beta_gamma.x) * forces[1] + alpha_beta_gamma.x * forces[2];
    float3 force47 = (1.0f - alpha_beta_gamma.x) * forces[4] + alpha_beta_gamma.x * forces[7];
    float3 force56 = (1.0f - alpha_beta_gamma.x) * forces[5] + alpha_beta_gamma.x * forces[6];

    float3 force0347 = (1.0f - alpha_beta_gamma.y) * force03 + alpha_beta_gamma.y * force47;
    float3 force1256 = (1.0f - alpha_beta_gamma.y) * force12 + alpha_beta_gamma.y * force56;

    return (1.0f - alpha_beta_gamma.z) * force0347 + alpha_beta_gamma.z * force1256;
}

Vertex CalculateComponentSharpFeatureVertex(Component component, out bool hasComponentSharpFeature)
{
    Vertex componentSharpFeatureVertex = CalculateComponentCenterVertex(component);
    hasComponentSharpFeature = HasComponentSharpFeature(component);

    if (hasComponentSharpFeature)
    {
        CalculateForces(component);

        for (uint iterations = 0; iterations < maxIterations; iterations++)
        {
            componentSharpFeatureVertex.position += stepSize * CalculateCombinedForce(componentSharpFeatureVertex.position.zyx);
        }
    }
    componentSharpFeatureVertex.position = ClampToVoxel(componentSharpFeatureVertex.position, 1e-1f);
    
    return componentSharpFeatureVertex;
}

void GenerateTriangle(uint3 id, uint3 vertexIndices, bool3 flatShaded)
{
    Vertex vertexA = generatedVertices[vertexIndices.x];
    Vertex vertexB = generatedVertices[vertexIndices.y];
    Vertex vertexC = generatedVertices[vertexIndices.z];

    float3 localPosition = CalculateLocalPosition(id);

    vertexA.position = voxelStride * voxelSpacing * vertexA.position + localPosition;
    vertexB.position = voxelStride * voxelSpacing * vertexB.position + localPosition;
    vertexC.position = voxelStride * voxelSpacing * vertexC.position + localPosition;

    float3 normal = normalize(cross(vertexB.position - vertexA.position, vertexC.position - vertexA.position));

#ifdef FLAT_SHADING
    vertexA.normal = normal;
    vertexB.normal = normal;
    vertexC.normal = normal;
#else
    vertexA.normal = flatShaded.x ? normal : vertexA.normal;
    vertexB.normal = flatShaded.y ? normal : vertexB.normal;
    vertexC.normal = flatShaded.z ? normal : vertexC.normal;
#endif

    generatedVertices[vertexIndices.x] = vertexA;
    generatedVertices[vertexIndices.y] = vertexB;
    generatedVertices[vertexIndices.z] = vertexC;

    generatedTriangles.Append(vertexIndices);
}

void GenerateTriangles(uint3 id, Component component, Vertex componentSharpFeatureVertex, bool hasComponentSharpFeature)
{
    for (uint index = 0; index < component.GetLength(); index++)
    {
        Segment segment = segments[component.GetPackedSegmentsIndex(index)];

        uint componentSharpFeatureVertexIndex = generatedVertices.IncrementCounter();
        generatedVertices[componentSharpFeatureVertexIndex] = componentSharpFeatureVertex;

        if (segment.GetSharpFeatureVertexIndexA() != -1)
        {
            GenerateTriangle
            (
                id,
                uint3(componentSharpFeatureVertexIndex, segment.GetSharpFeatureVertexIndexA(), segment.GetEdgeVertexIndexA()),
                bool3(hasComponentSharpFeature, true, false)
            );

            componentSharpFeatureVertexIndex = generatedVertices.IncrementCounter();
            generatedVertices[componentSharpFeatureVertexIndex] = componentSharpFeatureVertex;
                
            GenerateTriangle
            (
                id,
                uint3(segment.GetSharpFeatureVertexIndexB(), componentSharpFeatureVertexIndex, segment.GetEdgeVertexIndexB()),
                bool3(hasComponentSharpFeature, true, false)
            );
        }
        else
        {
            GenerateTriangle
            (
                id,
                uint3(componentSharpFeatureVertexIndex, segment.GetEdgeVertexIndexB(), segment.GetEdgeVertexIndexA()),
                bool3(hasComponentSharpFeature, false, false)
            );
        }
    }
}

[numthreads(4, 4, 4)]
void GenerateMesh(uint3 id : SV_DispatchThreadID)
{
    if (IsOutOfVoxelBounds(id))
    {
        return;
    }

    uint segmentsCount = 0;

    for (uint faceIndex = 0; faceIndex < voxelFacesCount; faceIndex++)
    {
        segmentsCount = GenerateFaceSegments(id, voxelFaces[faceIndex], segmentsCount);
    }

    if (segmentsCount == 0)
    {
        return;
    }

    uint componentsCount = TraceComponents(segmentsCount);
    
    for (uint componentsIndex = 0; componentsIndex < componentsCount; componentsIndex++)
    {
        bool hasComponentSharpFeature;
        Vertex componentSharpFeatureVertex = CalculateComponentSharpFeatureVertex(components[componentsIndex], hasComponentSharpFeature);

        GenerateTriangles(id, components[componentsIndex], componentSharpFeatureVertex, hasComponentSharpFeature);
    }
}
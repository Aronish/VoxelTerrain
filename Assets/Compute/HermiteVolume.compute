#pragma kernel GenerateHermiteVolume

#include "Assets/Compute/Include/HermiteFunctions.cginc"
#include "Assets/Compute/Include/VoxelVolume.cginc"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise3D.hlsl"

float noiseScale;
int octaves;
Buffer<float2> octaveOffsets;
float initialAmplitude;
float persistence;
float initialFrequency;
float lacunarity;
float sharpness;
Texture2D<float> heightMapScaling;
SamplerState LinearClampSampler;
float centralDifferenceSpacing;

float CalculateHeight(float2 position)
{
    float density = 0.0;
    float amplitude = initialAmplitude;
    float frequency = initialFrequency;
    float noiseHeight = 0.0;

    for (int index = 0; index < octaves; index++)
    {
        float2 samplePosition = position / noiseScale + octaveOffsets[index];
        float simplexNoise = snoise(frequency * float3(samplePosition.x, 0.0, samplePosition.y));
        float billowNoise = abs(simplexNoise);
        float ridgeNoise = 1.0 - billowNoise;
        float noise = sharpness < 0.0 ? lerp(simplexNoise, billowNoise, abs(sharpness)) : lerp(simplexNoise, ridgeNoise, sharpness);

        noiseHeight += amplitude * noise * heightMapScaling.SampleLevel(LinearClampSampler, float2(0.5 * (noise + 1.0), 0), 0);
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return noiseHeight;
}

float CalculateDensity(float3 position)
{
    return CalculateHeight(position.xz) - position.y;
}

float3 CalculateGradient(float3 position)
{
    float3 gradient;

    float halfSpacing = 0.5 * centralDifferenceSpacing * voxelSpacing;

    gradient.x = CalculateDensity(position - float3(halfSpacing, 0.0, 0.0)) - CalculateDensity(position + float3(halfSpacing, 0.0, 0.0));
    gradient.y = CalculateDensity(position - float3(0.0, halfSpacing, 0.0)) - CalculateDensity(position + float3(0.0, halfSpacing, 0.0));
    gradient.z = CalculateDensity(position - float3(0.0, 0.0, halfSpacing)) - CalculateDensity(position + float3(0.0, 0.0, halfSpacing));

    return gradient;
}

[numthreads(4, 4, 4)]
void GenerateHermiteVolume(uint3 id : SV_DispatchThreadID)
{
    if (IsOutOfHermiteBounds(id))
    {
        return;
    }

    uint index = CalculateHermiteIndex(id);
    float3 worldPosition = CalculateWorldPosition(id);

    HermiteData sample;
    InitializeHermiteData(sample, CalculateDensity(worldPosition), CalculateGradient(worldPosition));
    hermiteVolume[index] = sample;
}
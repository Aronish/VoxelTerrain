#pragma kernel GenerateDensityVolume

#include "Assets/Compute/Include/DensityFunctions.cginc"
#include "Assets/Compute/Include/ThreadCount.cginc"
#include "Assets/Compute/Include/VoxelVolume.cginc"
#include "Packages/jp.keijiro.noiseshader/Shader/SimplexNoise3D.hlsl"

float noiseScale;
int octaves;
Buffer<float2> octaveOffsets;
float initialAmplitude;
float persistence;
float initialFrequency;
float lacunarity;
float sharpness;
Texture2D<float> heightMapScaling;
SamplerState LinearClampSampler;
float centralDifferenceSpacing;

float CalculateHeight(float2 position)
{
    float density = 0.0;
    float amplitude = initialAmplitude;
    float frequency = initialFrequency;
    float noiseHeight = 0.0;

    for (int index = 0; index < octaves; index++)
    {
        float2 samplePosition = position / noiseScale + octaveOffsets[index];
        float simplexNoise = snoise(frequency * float3(samplePosition.x, 0.0, samplePosition.y));
        float billowNoise = abs(simplexNoise);
        float ridgeNoise = 1.0 - billowNoise;
        float noise = 0.0;

        if (sharpness < 0.0)
        {
            noise = lerp(simplexNoise, billowNoise, abs(sharpness));
        }
        else
        {
            noise = lerp(simplexNoise, ridgeNoise, sharpness);
        }

        noiseHeight += amplitude * noise * heightMapScaling.SampleLevel(LinearClampSampler, float2(0.5 * (noise + 1.0), 0), 0);
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return noiseHeight;
}

float CalculateDensity(float3 position)
{
    return CalculateHeight(position.xz) - position.y;
}

float3 CalculateGradient(float3 position)
{
    float3 gradient;

    float halfSpacing = 0.5 * centralDifferenceSpacing * voxelSpacing;

    gradient.x = CalculateDensity(position - float3(halfSpacing, 0.0, 0.0)) - CalculateDensity(position + float3(halfSpacing, 0.0, 0.0));
    gradient.y = CalculateDensity(position - float3(0.0, halfSpacing, 0.0)) - CalculateDensity(position + float3(0.0, halfSpacing, 0.0));
    gradient.z = CalculateDensity(position - float3(0.0, 0.0, halfSpacing)) - CalculateDensity(position + float3(0.0, 0.0, halfSpacing));

    return gradient;
}

[numthreads(threadCountDensityVolumeManipulator, threadCountDensityVolumeManipulator, threadCountDensityVolumeManipulator)]
void GenerateDensityVolume(uint3 id : SV_DispatchThreadID)
{
    if (IsOutOfDensityBounds(id))
    {
        return;
    }

    uint index = CalculateDensityIndex(id);
    float3 worldPosition = CalculateWorldPosition(id);

    densityVolume[index] = CalculateDensity(worldPosition);
    densityGradient[index] = CalculateGradient(worldPosition);
}